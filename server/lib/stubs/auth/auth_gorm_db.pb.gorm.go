package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type AuthenticationORM struct {
	Password string `gorm:"column:password"`
	UserID   uint64 `gorm:"column:user_id;primary_key;not null"`
	Username string `gorm:"column:username"`
}

// TableName overrides the default tablename generated by GORM
func (AuthenticationORM) TableName() string {
	return "authentications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Authentication) ToORM(ctx context.Context) (AuthenticationORM, error) {
	to := AuthenticationORM{}
	var err error
	if prehook, ok := interface{}(m).(AuthenticationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserID = m.UserID
	to.Username = m.Username
	to.Password = m.Password
	if posthook, ok := interface{}(m).(AuthenticationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AuthenticationORM) ToPB(ctx context.Context) (Authentication, error) {
	to := Authentication{}
	var err error
	if prehook, ok := interface{}(m).(AuthenticationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserID = m.UserID
	to.Username = m.Username
	to.Password = m.Password
	if posthook, ok := interface{}(m).(AuthenticationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Authentication the arg will be the target, the caller the one being converted from

// AuthenticationBeforeToORM called before default ToORM code
type AuthenticationWithBeforeToORM interface {
	BeforeToORM(context.Context, *AuthenticationORM) error
}

// AuthenticationAfterToORM called after default ToORM code
type AuthenticationWithAfterToORM interface {
	AfterToORM(context.Context, *AuthenticationORM) error
}

// AuthenticationBeforeToPB called before default ToPB code
type AuthenticationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Authentication) error
}

// AuthenticationAfterToPB called after default ToPB code
type AuthenticationWithAfterToPB interface {
	AfterToPB(context.Context, *Authentication) error
}

type UserLoginTimeORM struct {
	LastLoginTime *time.Time `gorm:"column:last_login_time"`
	UserID        uint64     `gorm:"column:user_id;primary_key;not null"`
	Username      string     `gorm:"column:username"`
}

// TableName overrides the default tablename generated by GORM
func (UserLoginTimeORM) TableName() string {
	return "user_login_times"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserLoginTime) ToORM(ctx context.Context) (UserLoginTimeORM, error) {
	to := UserLoginTimeORM{}
	var err error
	if prehook, ok := interface{}(m).(UserLoginTimeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserID = m.UserID
	to.Username = m.Username
	if m.LastLoginTime != nil {
		t := m.LastLoginTime.AsTime()
		to.LastLoginTime = &t
	}
	if posthook, ok := interface{}(m).(UserLoginTimeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserLoginTimeORM) ToPB(ctx context.Context) (UserLoginTime, error) {
	to := UserLoginTime{}
	var err error
	if prehook, ok := interface{}(m).(UserLoginTimeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserID = m.UserID
	to.Username = m.Username
	if m.LastLoginTime != nil {
		to.LastLoginTime = timestamppb.New(*m.LastLoginTime)
	}
	if posthook, ok := interface{}(m).(UserLoginTimeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserLoginTime the arg will be the target, the caller the one being converted from

// UserLoginTimeBeforeToORM called before default ToORM code
type UserLoginTimeWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserLoginTimeORM) error
}

// UserLoginTimeAfterToORM called after default ToORM code
type UserLoginTimeWithAfterToORM interface {
	AfterToORM(context.Context, *UserLoginTimeORM) error
}

// UserLoginTimeBeforeToPB called before default ToPB code
type UserLoginTimeWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserLoginTime) error
}

// UserLoginTimeAfterToPB called after default ToPB code
type UserLoginTimeWithAfterToPB interface {
	AfterToPB(context.Context, *UserLoginTime) error
}

type JailORM struct {
	CreatedAt *time.Time
	ExpiredAt *time.Time
	JailID    uint64 `gorm:"column:JailID;primary_key;not null"`
	Token     string `gorm:"column:Token;type:text;unique;not null"`
	TokenType string `gorm:"column:TokenType;type:varchar(255)"`
}

// TableName overrides the default tablename generated by GORM
func (JailORM) TableName() string {
	return "token_jail"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Jail) ToORM(ctx context.Context) (JailORM, error) {
	to := JailORM{}
	var err error
	if prehook, ok := interface{}(m).(JailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.JailID = m.JailID
	to.Token = m.Token
	to.TokenType = m.TokenType
	if m.ExpiredAt != nil {
		t := m.ExpiredAt.AsTime()
		to.ExpiredAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(JailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JailORM) ToPB(ctx context.Context) (Jail, error) {
	to := Jail{}
	var err error
	if prehook, ok := interface{}(m).(JailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.JailID = m.JailID
	to.Token = m.Token
	to.TokenType = m.TokenType
	if m.ExpiredAt != nil {
		to.ExpiredAt = timestamppb.New(*m.ExpiredAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(JailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Jail the arg will be the target, the caller the one being converted from

// JailBeforeToORM called before default ToORM code
type JailWithBeforeToORM interface {
	BeforeToORM(context.Context, *JailORM) error
}

// JailAfterToORM called after default ToORM code
type JailWithAfterToORM interface {
	AfterToORM(context.Context, *JailORM) error
}

// JailBeforeToPB called before default ToPB code
type JailWithBeforeToPB interface {
	BeforeToPB(context.Context, *Jail) error
}

// JailAfterToPB called after default ToPB code
type JailWithAfterToPB interface {
	AfterToPB(context.Context, *Jail) error
}

type TokenStoreORM struct {
	CreatedAt *time.Time `gorm:"column:CreatedAt"`
	DateTime  string     `gorm:"column:DateTime"`
	SessionID string     `gorm:"column:SessionID;type:text;not null"`
	Token     string     `gorm:"column:Token;type:text;primary_key;unique;not null"`
	UpdatedAt *time.Time `gorm:"column:UpdatedAt"`
	UserID    uint64     `gorm:"column:UserID;not null"`
	Username  string     `gorm:"column:Username;not null"`
}

// TableName overrides the default tablename generated by GORM
func (TokenStoreORM) TableName() string {
	return "token_store"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TokenStore) ToORM(ctx context.Context) (TokenStoreORM, error) {
	to := TokenStoreORM{}
	var err error
	if prehook, ok := interface{}(m).(TokenStoreWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Token = m.Token
	to.UserID = m.UserID
	to.Username = m.Username
	to.SessionID = m.SessionID
	to.DateTime = m.DateTime
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(TokenStoreWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TokenStoreORM) ToPB(ctx context.Context) (TokenStore, error) {
	to := TokenStore{}
	var err error
	if prehook, ok := interface{}(m).(TokenStoreWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Token = m.Token
	to.UserID = m.UserID
	to.Username = m.Username
	to.SessionID = m.SessionID
	to.DateTime = m.DateTime
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(TokenStoreWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TokenStore the arg will be the target, the caller the one being converted from

// TokenStoreBeforeToORM called before default ToORM code
type TokenStoreWithBeforeToORM interface {
	BeforeToORM(context.Context, *TokenStoreORM) error
}

// TokenStoreAfterToORM called after default ToORM code
type TokenStoreWithAfterToORM interface {
	AfterToORM(context.Context, *TokenStoreORM) error
}

// TokenStoreBeforeToPB called before default ToPB code
type TokenStoreWithBeforeToPB interface {
	BeforeToPB(context.Context, *TokenStore) error
}

// TokenStoreAfterToPB called after default ToPB code
type TokenStoreWithAfterToPB interface {
	AfterToPB(context.Context, *TokenStore) error
}

type SessionIDPairORM struct {
	CreatedAt *time.Time
	ExpiredAt *time.Time
	PairID    uint64 `gorm:"column:PairID;primary_key;not null"`
	SessionID string `gorm:"column:SessionID;type:text;unique;not null"`
	Token     string `gorm:"column:Token;type:text;unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (SessionIDPairORM) TableName() string {
	return "session_id_pair"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SessionIDPair) ToORM(ctx context.Context) (SessionIDPairORM, error) {
	to := SessionIDPairORM{}
	var err error
	if prehook, ok := interface{}(m).(SessionIDPairWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.PairID = m.PairID
	to.SessionID = m.SessionID
	to.Token = m.Token
	if m.ExpiredAt != nil {
		t := m.ExpiredAt.AsTime()
		to.ExpiredAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(SessionIDPairWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SessionIDPairORM) ToPB(ctx context.Context) (SessionIDPair, error) {
	to := SessionIDPair{}
	var err error
	if prehook, ok := interface{}(m).(SessionIDPairWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.PairID = m.PairID
	to.SessionID = m.SessionID
	to.Token = m.Token
	if m.ExpiredAt != nil {
		to.ExpiredAt = timestamppb.New(*m.ExpiredAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(SessionIDPairWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SessionIDPair the arg will be the target, the caller the one being converted from

// SessionIDPairBeforeToORM called before default ToORM code
type SessionIDPairWithBeforeToORM interface {
	BeforeToORM(context.Context, *SessionIDPairORM) error
}

// SessionIDPairAfterToORM called after default ToORM code
type SessionIDPairWithAfterToORM interface {
	AfterToORM(context.Context, *SessionIDPairORM) error
}

// SessionIDPairBeforeToPB called before default ToPB code
type SessionIDPairWithBeforeToPB interface {
	BeforeToPB(context.Context, *SessionIDPair) error
}

// SessionIDPairAfterToPB called after default ToPB code
type SessionIDPairWithAfterToPB interface {
	AfterToPB(context.Context, *SessionIDPair) error
}

// DefaultCreateAuthentication executes a basic gorm create call
func DefaultCreateAuthentication(ctx context.Context, in *Authentication, db *gorm.DB) (*Authentication, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AuthenticationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAuthentication(ctx context.Context, in *Authentication, db *gorm.DB) (*Authentication, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.UserID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AuthenticationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AuthenticationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AuthenticationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AuthenticationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAuthentication(ctx context.Context, in *Authentication, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.UserID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AuthenticationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AuthenticationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAuthenticationSet(ctx context.Context, in []*Authentication, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.UserID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.UserID)
	}
	if hook, ok := (interface{}(&AuthenticationORM{})).(AuthenticationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("user_id in (?)", keys).Delete(&AuthenticationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AuthenticationORM{})).(AuthenticationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AuthenticationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Authentication, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Authentication, *gorm.DB) error
}

// DefaultStrictUpdateAuthentication clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAuthentication(ctx context.Context, in *Authentication, db *gorm.DB) (*Authentication, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAuthentication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AuthenticationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("user_id=?", ormObj.UserID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AuthenticationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAuthentication executes a basic gorm update call with patch behavior
func DefaultPatchAuthentication(ctx context.Context, in *Authentication, updateMask *field_mask.FieldMask, db *gorm.DB) (*Authentication, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Authentication
	var err error
	if hook, ok := interface{}(&pbObj).(AuthenticationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(AuthenticationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAuthentication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AuthenticationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAuthentication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AuthenticationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AuthenticationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Authentication, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Authentication, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Authentication, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Authentication, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAuthentication executes a bulk gorm update call with patch behavior
func DefaultPatchSetAuthentication(ctx context.Context, objects []*Authentication, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Authentication, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Authentication, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAuthentication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAuthentication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAuthentication(ctx context.Context, patchee *Authentication, patcher *Authentication, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Authentication, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAuthentication executes a gorm list call
func DefaultListAuthentication(ctx context.Context, db *gorm.DB) ([]*Authentication, error) {
	in := Authentication{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AuthenticationORM{}, &Authentication{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("user_id")
	ormResponse := []AuthenticationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuthenticationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Authentication{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AuthenticationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AuthenticationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AuthenticationORM) error
}

// DefaultCreateUserLoginTime executes a basic gorm create call
func DefaultCreateUserLoginTime(ctx context.Context, in *UserLoginTime, db *gorm.DB) (*UserLoginTime, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserLoginTimeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserLoginTime(ctx context.Context, in *UserLoginTime, db *gorm.DB) (*UserLoginTime, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.UserID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserLoginTimeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserLoginTimeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserLoginTimeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserLoginTimeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserLoginTime(ctx context.Context, in *UserLoginTime, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.UserID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserLoginTimeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserLoginTimeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserLoginTimeSet(ctx context.Context, in []*UserLoginTime, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.UserID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.UserID)
	}
	if hook, ok := (interface{}(&UserLoginTimeORM{})).(UserLoginTimeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("user_id in (?)", keys).Delete(&UserLoginTimeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserLoginTimeORM{})).(UserLoginTimeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserLoginTimeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserLoginTime, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserLoginTime, *gorm.DB) error
}

// DefaultStrictUpdateUserLoginTime clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserLoginTime(ctx context.Context, in *UserLoginTime, db *gorm.DB) (*UserLoginTime, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserLoginTime")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserLoginTimeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("user_id=?", ormObj.UserID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserLoginTimeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserLoginTime executes a basic gorm update call with patch behavior
func DefaultPatchUserLoginTime(ctx context.Context, in *UserLoginTime, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserLoginTime, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserLoginTime
	var err error
	if hook, ok := interface{}(&pbObj).(UserLoginTimeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(UserLoginTimeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserLoginTime(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserLoginTimeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserLoginTime(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserLoginTimeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserLoginTimeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserLoginTime, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserLoginTime, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserLoginTime, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserLoginTime, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserLoginTime executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserLoginTime(ctx context.Context, objects []*UserLoginTime, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserLoginTime, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserLoginTime, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserLoginTime(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserLoginTime patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserLoginTime(ctx context.Context, patchee *UserLoginTime, patcher *UserLoginTime, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserLoginTime, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastLoginTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if !updatedLastLoginTime && strings.HasPrefix(f, prefix+"LastLoginTime.") {
			if patcher.LastLoginTime == nil {
				patchee.LastLoginTime = nil
				continue
			}
			if patchee.LastLoginTime == nil {
				patchee.LastLoginTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastLoginTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastLoginTime, patchee.LastLoginTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastLoginTime" {
			updatedLastLoginTime = true
			patchee.LastLoginTime = patcher.LastLoginTime
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserLoginTime executes a gorm list call
func DefaultListUserLoginTime(ctx context.Context, db *gorm.DB) ([]*UserLoginTime, error) {
	in := UserLoginTime{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserLoginTimeORM{}, &UserLoginTime{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("user_id")
	ormResponse := []UserLoginTimeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserLoginTimeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserLoginTime{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserLoginTimeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserLoginTimeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserLoginTimeORM) error
}

// DefaultCreateJail executes a basic gorm create call
func DefaultCreateJail(ctx context.Context, in *Jail, db *gorm.DB) (*Jail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJail(ctx context.Context, in *Jail, db *gorm.DB) (*Jail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.JailID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJail(ctx context.Context, in *Jail, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.JailID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJailSet(ctx context.Context, in []*Jail, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.JailID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.JailID)
	}
	if hook, ok := (interface{}(&JailORM{})).(JailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("jail_id in (?)", keys).Delete(&JailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JailORM{})).(JailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Jail, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Jail, *gorm.DB) error
}

// DefaultStrictUpdateJail clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJail(ctx context.Context, in *Jail, db *gorm.DB) (*Jail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("JailID=?", ormObj.JailID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJail executes a basic gorm update call with patch behavior
func DefaultPatchJail(ctx context.Context, in *Jail, updateMask *field_mask.FieldMask, db *gorm.DB) (*Jail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Jail
	var err error
	if hook, ok := interface{}(&pbObj).(JailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(JailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Jail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Jail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Jail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Jail, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJail executes a bulk gorm update call with patch behavior
func DefaultPatchSetJail(ctx context.Context, objects []*Jail, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Jail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Jail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJail(ctx context.Context, patchee *Jail, patcher *Jail, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Jail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedExpiredAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"JailID" {
			patchee.JailID = patcher.JailID
			continue
		}
		if f == prefix+"Token" {
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"TokenType" {
			patchee.TokenType = patcher.TokenType
			continue
		}
		if !updatedExpiredAt && strings.HasPrefix(f, prefix+"ExpiredAt.") {
			if patcher.ExpiredAt == nil {
				patchee.ExpiredAt = nil
				continue
			}
			if patchee.ExpiredAt == nil {
				patchee.ExpiredAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiredAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiredAt, patchee.ExpiredAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiredAt" {
			updatedExpiredAt = true
			patchee.ExpiredAt = patcher.ExpiredAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJail executes a gorm list call
func DefaultListJail(ctx context.Context, db *gorm.DB) ([]*Jail, error) {
	in := Jail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JailORM{}, &Jail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("JailID")
	ormResponse := []JailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Jail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JailORM) error
}

// DefaultCreateTokenStore executes a basic gorm create call
func DefaultCreateTokenStore(ctx context.Context, in *TokenStore, db *gorm.DB) (*TokenStore, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TokenStoreORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTokenStore(ctx context.Context, in *TokenStore, db *gorm.DB) (*TokenStore, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Token == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TokenStoreORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TokenStoreORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TokenStoreORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TokenStoreORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTokenStore(ctx context.Context, in *TokenStore, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Token == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TokenStoreORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TokenStoreORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTokenStoreSet(ctx context.Context, in []*TokenStore, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Token == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Token)
	}
	if hook, ok := (interface{}(&TokenStoreORM{})).(TokenStoreORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("token in (?)", keys).Delete(&TokenStoreORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TokenStoreORM{})).(TokenStoreORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TokenStoreORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TokenStore, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TokenStore, *gorm.DB) error
}

// DefaultStrictUpdateTokenStore clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTokenStore(ctx context.Context, in *TokenStore, db *gorm.DB) (*TokenStore, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTokenStore")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TokenStoreORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("Token=?", ormObj.Token).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TokenStoreORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTokenStore executes a basic gorm update call with patch behavior
func DefaultPatchTokenStore(ctx context.Context, in *TokenStore, updateMask *field_mask.FieldMask, db *gorm.DB) (*TokenStore, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TokenStore
	var err error
	if hook, ok := interface{}(&pbObj).(TokenStoreWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(TokenStoreWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTokenStore(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TokenStoreWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTokenStore(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TokenStoreWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TokenStoreWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TokenStore, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TokenStore, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TokenStore, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TokenStore, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTokenStore executes a bulk gorm update call with patch behavior
func DefaultPatchSetTokenStore(ctx context.Context, objects []*TokenStore, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TokenStore, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TokenStore, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTokenStore(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTokenStore patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTokenStore(ctx context.Context, patchee *TokenStore, patcher *TokenStore, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TokenStore, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Token" {
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"SessionID" {
			patchee.SessionID = patcher.SessionID
			continue
		}
		if f == prefix+"DateTime" {
			patchee.DateTime = patcher.DateTime
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTokenStore executes a gorm list call
func DefaultListTokenStore(ctx context.Context, db *gorm.DB) ([]*TokenStore, error) {
	in := TokenStore{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TokenStoreORM{}, &TokenStore{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("Token")
	ormResponse := []TokenStoreORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenStoreORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TokenStore{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TokenStoreORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenStoreORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TokenStoreORM) error
}

// DefaultCreateSessionIDPair executes a basic gorm create call
func DefaultCreateSessionIDPair(ctx context.Context, in *SessionIDPair, db *gorm.DB) (*SessionIDPair, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SessionIDPairORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSessionIDPair(ctx context.Context, in *SessionIDPair, db *gorm.DB) (*SessionIDPair, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.PairID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SessionIDPairORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SessionIDPairORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SessionIDPairORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SessionIDPairORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSessionIDPair(ctx context.Context, in *SessionIDPair, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.PairID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SessionIDPairORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SessionIDPairORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSessionIDPairSet(ctx context.Context, in []*SessionIDPair, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.PairID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.PairID)
	}
	if hook, ok := (interface{}(&SessionIDPairORM{})).(SessionIDPairORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("pair_id in (?)", keys).Delete(&SessionIDPairORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SessionIDPairORM{})).(SessionIDPairORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SessionIDPairORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SessionIDPair, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SessionIDPair, *gorm.DB) error
}

// DefaultStrictUpdateSessionIDPair clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSessionIDPair(ctx context.Context, in *SessionIDPair, db *gorm.DB) (*SessionIDPair, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSessionIDPair")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SessionIDPairORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("PairID=?", ormObj.PairID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SessionIDPairORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSessionIDPair executes a basic gorm update call with patch behavior
func DefaultPatchSessionIDPair(ctx context.Context, in *SessionIDPair, updateMask *field_mask.FieldMask, db *gorm.DB) (*SessionIDPair, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SessionIDPair
	var err error
	if hook, ok := interface{}(&pbObj).(SessionIDPairWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(SessionIDPairWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSessionIDPair(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SessionIDPairWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSessionIDPair(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SessionIDPairWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SessionIDPairWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SessionIDPair, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SessionIDPair, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SessionIDPair, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SessionIDPair, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSessionIDPair executes a bulk gorm update call with patch behavior
func DefaultPatchSetSessionIDPair(ctx context.Context, objects []*SessionIDPair, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SessionIDPair, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SessionIDPair, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSessionIDPair(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSessionIDPair patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSessionIDPair(ctx context.Context, patchee *SessionIDPair, patcher *SessionIDPair, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SessionIDPair, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedExpiredAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"PairID" {
			patchee.PairID = patcher.PairID
			continue
		}
		if f == prefix+"SessionID" {
			patchee.SessionID = patcher.SessionID
			continue
		}
		if f == prefix+"Token" {
			patchee.Token = patcher.Token
			continue
		}
		if !updatedExpiredAt && strings.HasPrefix(f, prefix+"ExpiredAt.") {
			if patcher.ExpiredAt == nil {
				patchee.ExpiredAt = nil
				continue
			}
			if patchee.ExpiredAt == nil {
				patchee.ExpiredAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ExpiredAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ExpiredAt, patchee.ExpiredAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ExpiredAt" {
			updatedExpiredAt = true
			patchee.ExpiredAt = patcher.ExpiredAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSessionIDPair executes a gorm list call
func DefaultListSessionIDPair(ctx context.Context, db *gorm.DB) ([]*SessionIDPair, error) {
	in := SessionIDPair{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SessionIDPairORM{}, &SessionIDPair{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("PairID")
	ormResponse := []SessionIDPairORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SessionIDPairORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SessionIDPair{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SessionIDPairORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SessionIDPairORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SessionIDPairORM) error
}
