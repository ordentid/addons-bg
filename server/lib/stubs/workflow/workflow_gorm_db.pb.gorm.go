package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type WorkflowORM struct {
	CompanyID             uint64              `gorm:"column:CompanyID;not null"`
	CreatedAt             *time.Time          `gorm:"column:CreatedAt;not null"`
	CreatedByID           uint64              `gorm:"column:CreatedByID;not null"`
	CurrencyID            uint64              `gorm:"column:CurrencyID"`
	CurrencyName          string              `gorm:"column:currencyName;type:varchar(255)"`
	DeletedAt             *time.Time          `gorm:"column:DeletedAt"`
	DeletedByID           uint64              `gorm:"column:DeletedByID"`
	Description           string              `gorm:"column:Description;type:varchar(255)"`
	IsCreatedInputAccount bool                `gorm:"column:IsCreatedInputAccount"`
	IsCustomInputAccount  bool                `gorm:"column:IsCustomInputAccount"`
	Logics                []*WorkflowLogicORM `gorm:"foreignkey:WorkflowID;association_foreignkey:WorkflowID;preload:true;append:true"`
	ModuleID              uint64              `gorm:"column:ModuleID;not null"`
	UpdatedAt             *time.Time          `gorm:"column:UpdatedAt;not null"`
	UpdatedByID           uint64              `gorm:"column:UpdatedByID;not null"`
	WorkflowCode          string              `gorm:"column:WorkflowCode;type:varchar(255);not null"`
	WorkflowID            uint64              `gorm:"column:WorkflowID;primary_key;not null;auto_increment"`
}

// TableName overrides the default tablename generated by GORM
func (WorkflowORM) TableName() string {
	return "workflows"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Workflow) ToORM(ctx context.Context) (WorkflowORM, error) {
	to := WorkflowORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkflowWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowID = m.WorkflowID
	to.ModuleID = m.ModuleID
	to.CompanyID = m.CompanyID
	to.CurrencyID = m.CurrencyID
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	to.CurrencyName = m.CurrencyName
	to.WorkflowCode = m.WorkflowCode
	to.Description = m.Description
	to.IsCustomInputAccount = m.IsCustomInputAccount
	to.IsCreatedInputAccount = m.IsCreatedInputAccount
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.Logics {
		if v != nil {
			if tempLogics, cErr := v.ToORM(ctx); cErr == nil {
				to.Logics = append(to.Logics, &tempLogics)
			} else {
				return to, cErr
			}
		} else {
			to.Logics = append(to.Logics, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkflowWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkflowORM) ToPB(ctx context.Context) (Workflow, error) {
	to := Workflow{}
	var err error
	if prehook, ok := interface{}(m).(WorkflowWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowID = m.WorkflowID
	to.ModuleID = m.ModuleID
	to.CompanyID = m.CompanyID
	to.CurrencyID = m.CurrencyID
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	to.CurrencyName = m.CurrencyName
	to.WorkflowCode = m.WorkflowCode
	to.Description = m.Description
	to.IsCustomInputAccount = m.IsCustomInputAccount
	to.IsCreatedInputAccount = m.IsCreatedInputAccount
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.Logics {
		if v != nil {
			if tempLogics, cErr := v.ToPB(ctx); cErr == nil {
				to.Logics = append(to.Logics, &tempLogics)
			} else {
				return to, cErr
			}
		} else {
			to.Logics = append(to.Logics, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkflowWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Workflow the arg will be the target, the caller the one being converted from

// WorkflowBeforeToORM called before default ToORM code
type WorkflowWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkflowORM) error
}

// WorkflowAfterToORM called after default ToORM code
type WorkflowWithAfterToORM interface {
	AfterToORM(context.Context, *WorkflowORM) error
}

// WorkflowBeforeToPB called before default ToPB code
type WorkflowWithBeforeToPB interface {
	BeforeToPB(context.Context, *Workflow) error
}

// WorkflowAfterToPB called after default ToPB code
type WorkflowWithAfterToPB interface {
	AfterToPB(context.Context, *Workflow) error
}

type WorkflowLogicORM struct {
	BottomRange     uint64                    `gorm:"column:BottomRange;not null"`
	CreatedAt       *time.Time                `gorm:"column:CreatedAt;not null"`
	CreatedByID     uint64                    `gorm:"column:CreatedByID;not null"`
	Requirements    []*WorkflowRequirementORM `gorm:"foreignkey:WorkflowLogicID;association_foreignkey:WorkflowLogicID;preload:true;append:true"`
	TopRange        uint64                    `gorm:"column:TopRange;not null"`
	UpdatedAt       *time.Time                `gorm:"column:UpdatedAt;not null"`
	UpdatedByID     uint64                    `gorm:"column:UpdatedByID;not null"`
	WorkflowID      uint64                    `gorm:"column:WorkflowID;not null"`
	WorkflowLogicID uint64                    `gorm:"column:WorkflowLogicID;primary_key;not null;auto_increment"`
}

// TableName overrides the default tablename generated by GORM
func (WorkflowLogicORM) TableName() string {
	return "workflow_logics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *WorkflowLogic) ToORM(ctx context.Context) (WorkflowLogicORM, error) {
	to := WorkflowLogicORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkflowLogicWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowLogicID = m.WorkflowLogicID
	to.WorkflowID = m.WorkflowID
	to.BottomRange = m.BottomRange
	to.TopRange = m.TopRange
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	for _, v := range m.Requirements {
		if v != nil {
			if tempRequirements, cErr := v.ToORM(ctx); cErr == nil {
				to.Requirements = append(to.Requirements, &tempRequirements)
			} else {
				return to, cErr
			}
		} else {
			to.Requirements = append(to.Requirements, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkflowLogicWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkflowLogicORM) ToPB(ctx context.Context) (WorkflowLogic, error) {
	to := WorkflowLogic{}
	var err error
	if prehook, ok := interface{}(m).(WorkflowLogicWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowLogicID = m.WorkflowLogicID
	to.WorkflowID = m.WorkflowID
	to.BottomRange = m.BottomRange
	to.TopRange = m.TopRange
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	for _, v := range m.Requirements {
		if v != nil {
			if tempRequirements, cErr := v.ToPB(ctx); cErr == nil {
				to.Requirements = append(to.Requirements, &tempRequirements)
			} else {
				return to, cErr
			}
		} else {
			to.Requirements = append(to.Requirements, nil)
		}
	}
	if posthook, ok := interface{}(m).(WorkflowLogicWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type WorkflowLogic the arg will be the target, the caller the one being converted from

// WorkflowLogicBeforeToORM called before default ToORM code
type WorkflowLogicWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkflowLogicORM) error
}

// WorkflowLogicAfterToORM called after default ToORM code
type WorkflowLogicWithAfterToORM interface {
	AfterToORM(context.Context, *WorkflowLogicORM) error
}

// WorkflowLogicBeforeToPB called before default ToPB code
type WorkflowLogicWithBeforeToPB interface {
	BeforeToPB(context.Context, *WorkflowLogic) error
}

// WorkflowLogicAfterToPB called after default ToPB code
type WorkflowLogicWithAfterToPB interface {
	AfterToPB(context.Context, *WorkflowLogic) error
}

type WorkflowRequirementORM struct {
	CreatedAt             *time.Time `gorm:"column:CreatedAt;not null"`
	CreatedByID           uint64     `gorm:"column:CreatedByID;not null"`
	MinimumNumber         uint32     `gorm:"column:MinimumNumber;not null"`
	Priority              uint32     `gorm:"column:Priority;not null"`
	RoleID                uint64     `gorm:"column:RoleID;not null"`
	Step                  string     `gorm:"column:Step;default:maker;not null"`
	UpdatedAt             *time.Time `gorm:"column:UpdatedAt;not null"`
	UpdatedByID           uint64     `gorm:"column:UpdatedByID;not null"`
	WorkflowLogicID       uint64     `gorm:"column:WorkflowLogicID;not null"`
	WorkflowRequirementID uint64     `gorm:"column:WorkflowRequirementID;primary_key;not null;auto_increment"`
}

// TableName overrides the default tablename generated by GORM
func (WorkflowRequirementORM) TableName() string {
	return "workflow_requirements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *WorkflowRequirement) ToORM(ctx context.Context) (WorkflowRequirementORM, error) {
	to := WorkflowRequirementORM{}
	var err error
	if prehook, ok := interface{}(m).(WorkflowRequirementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowRequirementID = m.WorkflowRequirementID
	to.WorkflowLogicID = m.WorkflowLogicID
	to.Step = m.Step
	to.RoleID = m.RoleID
	to.Priority = m.Priority
	to.MinimumNumber = m.MinimumNumber
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(WorkflowRequirementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *WorkflowRequirementORM) ToPB(ctx context.Context) (WorkflowRequirement, error) {
	to := WorkflowRequirement{}
	var err error
	if prehook, ok := interface{}(m).(WorkflowRequirementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowRequirementID = m.WorkflowRequirementID
	to.WorkflowLogicID = m.WorkflowLogicID
	to.Step = m.Step
	to.RoleID = m.RoleID
	to.Priority = m.Priority
	to.MinimumNumber = m.MinimumNumber
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(WorkflowRequirementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type WorkflowRequirement the arg will be the target, the caller the one being converted from

// WorkflowRequirementBeforeToORM called before default ToORM code
type WorkflowRequirementWithBeforeToORM interface {
	BeforeToORM(context.Context, *WorkflowRequirementORM) error
}

// WorkflowRequirementAfterToORM called after default ToORM code
type WorkflowRequirementWithAfterToORM interface {
	AfterToORM(context.Context, *WorkflowRequirementORM) error
}

// WorkflowRequirementBeforeToPB called before default ToPB code
type WorkflowRequirementWithBeforeToPB interface {
	BeforeToPB(context.Context, *WorkflowRequirement) error
}

// WorkflowRequirementAfterToPB called after default ToPB code
type WorkflowRequirementWithAfterToPB interface {
	AfterToPB(context.Context, *WorkflowRequirement) error
}

type CompanyWorkflowsORM struct {
	CompanyID                uint64     `gorm:"column:companyID"`
	CreatedAt                *time.Time `gorm:"column:CreatedAt;not null"`
	CreatedByID              uint64     `gorm:"column:CreatedByID;not null"`
	DeletedAt                *time.Time `gorm:"column:DeletedAt"`
	DeletedByID              uint64     `gorm:"column:DeletedByID"`
	IsNonTransactionChecker  bool       `gorm:"column:IsNonTransactionChecker"`
	IsNonTransactionReleaser bool       `gorm:"column:IsNonTransactionReleaser"`
	IsNonTransactionSTP      bool       `gorm:"column:IsNonTransactionSTP"`
	IsNonTransactionSigner   bool       `gorm:"column:IsNonTransactionSigner"`
	IsTransactionChecker     bool       `gorm:"column:IsTransactionChecker"`
	IsTransactionReleaser    bool       `gorm:"column:IsTransactionReleaser"`
	IsTransactionSTP         bool       `gorm:"column:IsTransactionSTP"`
	IsTransactionSigner      bool       `gorm:"column:IsTransactionSigner"`
	UpdatedAt                *time.Time `gorm:"column:UpdatedAt;not null"`
	UpdatedByID              uint64     `gorm:"column:UpdatedByID;not null"`
	WorkflowCompanyID        uint64     `gorm:"column:WorkflowCompanyID;primary_key;not null;auto_increment"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyWorkflowsORM) TableName() string {
	return "company_workflows"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyWorkflows) ToORM(ctx context.Context) (CompanyWorkflowsORM, error) {
	to := CompanyWorkflowsORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWorkflowsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowCompanyID = m.WorkflowCompanyID
	to.IsTransactionSTP = m.IsTransactionSTP
	to.IsTransactionChecker = m.IsTransactionChecker
	to.IsTransactionSigner = m.IsTransactionSigner
	to.IsTransactionReleaser = m.IsTransactionReleaser
	to.IsNonTransactionSTP = m.IsNonTransactionSTP
	to.IsNonTransactionChecker = m.IsNonTransactionChecker
	to.IsNonTransactionSigner = m.IsNonTransactionSigner
	to.IsNonTransactionReleaser = m.IsNonTransactionReleaser
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	to.CompanyID = m.CompanyID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(CompanyWorkflowsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyWorkflowsORM) ToPB(ctx context.Context) (CompanyWorkflows, error) {
	to := CompanyWorkflows{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWorkflowsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.WorkflowCompanyID = m.WorkflowCompanyID
	to.IsTransactionSTP = m.IsTransactionSTP
	to.IsTransactionChecker = m.IsTransactionChecker
	to.IsTransactionSigner = m.IsTransactionSigner
	to.IsTransactionReleaser = m.IsTransactionReleaser
	to.IsNonTransactionSTP = m.IsNonTransactionSTP
	to.IsNonTransactionChecker = m.IsNonTransactionChecker
	to.IsNonTransactionSigner = m.IsNonTransactionSigner
	to.IsNonTransactionReleaser = m.IsNonTransactionReleaser
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	to.CompanyID = m.CompanyID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(CompanyWorkflowsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyWorkflows the arg will be the target, the caller the one being converted from

// CompanyWorkflowsBeforeToORM called before default ToORM code
type CompanyWorkflowsWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyWorkflowsORM) error
}

// CompanyWorkflowsAfterToORM called after default ToORM code
type CompanyWorkflowsWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyWorkflowsORM) error
}

// CompanyWorkflowsBeforeToPB called before default ToPB code
type CompanyWorkflowsWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyWorkflows) error
}

// CompanyWorkflowsAfterToPB called after default ToPB code
type CompanyWorkflowsWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyWorkflows) error
}

// DefaultCreateWorkflow executes a basic gorm create call
func DefaultCreateWorkflow(ctx context.Context, in *Workflow, db *gorm.DB) (*Workflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkflowORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkflow(ctx context.Context, in *Workflow, db *gorm.DB) (*Workflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.WorkflowID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &WorkflowORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkflowORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkflowORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkflowORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkflow(ctx context.Context, in *Workflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.WorkflowID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkflowORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkflowSet(ctx context.Context, in []*Workflow, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.WorkflowID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.WorkflowID)
	}
	if hook, ok := (interface{}(&WorkflowORM{})).(WorkflowORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("workflow_id in (?)", keys).Delete(&WorkflowORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkflowORM{})).(WorkflowORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkflowORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Workflow, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Workflow, *gorm.DB) error
}

// DefaultStrictUpdateWorkflow clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkflow(ctx context.Context, in *Workflow, db *gorm.DB) (*Workflow, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkflow")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkflowORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("WorkflowID=?", ormObj.WorkflowID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Logics").Append(ormObj.Logics).Error; err != nil {
		return nil, err
	}
	ormObj.Logics = nil
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkflowORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkflow executes a basic gorm update call with patch behavior
func DefaultPatchWorkflow(ctx context.Context, in *Workflow, updateMask *field_mask.FieldMask, db *gorm.DB) (*Workflow, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Workflow
	var err error
	if hook, ok := interface{}(&pbObj).(WorkflowWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(WorkflowWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkflow(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkflowWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkflow(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkflowWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkflowWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Workflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Workflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Workflow, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Workflow, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkflow executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkflow(ctx context.Context, objects []*Workflow, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Workflow, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Workflow, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkflow(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkflow patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkflow(ctx context.Context, patchee *Workflow, patcher *Workflow, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Workflow, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"WorkflowID" {
			patchee.WorkflowID = patcher.WorkflowID
			continue
		}
		if f == prefix+"ModuleID" {
			patchee.ModuleID = patcher.ModuleID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"CurrencyName" {
			patchee.CurrencyName = patcher.CurrencyName
			continue
		}
		if f == prefix+"WorkflowCode" {
			patchee.WorkflowCode = patcher.WorkflowCode
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"IsCustomInputAccount" {
			patchee.IsCustomInputAccount = patcher.IsCustomInputAccount
			continue
		}
		if f == prefix+"IsCreatedInputAccount" {
			patchee.IsCreatedInputAccount = patcher.IsCreatedInputAccount
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Logics" {
			patchee.Logics = patcher.Logics
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkflow executes a gorm list call
func DefaultListWorkflow(ctx context.Context, db *gorm.DB) ([]*Workflow, error) {
	in := Workflow{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &WorkflowORM{}, &Workflow{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("WorkflowID")
	ormResponse := []WorkflowORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Workflow{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkflowORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkflowORM) error
}

// DefaultCreateWorkflowLogic executes a basic gorm create call
func DefaultCreateWorkflowLogic(ctx context.Context, in *WorkflowLogic, db *gorm.DB) (*WorkflowLogic, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkflowLogicORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkflowLogic(ctx context.Context, in *WorkflowLogic, db *gorm.DB) (*WorkflowLogic, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.WorkflowLogicID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &WorkflowLogicORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkflowLogicORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkflowLogicORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkflowLogicORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkflowLogic(ctx context.Context, in *WorkflowLogic, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.WorkflowLogicID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkflowLogicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkflowLogicORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkflowLogicSet(ctx context.Context, in []*WorkflowLogic, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.WorkflowLogicID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.WorkflowLogicID)
	}
	if hook, ok := (interface{}(&WorkflowLogicORM{})).(WorkflowLogicORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("workflow_logic_id in (?)", keys).Delete(&WorkflowLogicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkflowLogicORM{})).(WorkflowLogicORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkflowLogicORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*WorkflowLogic, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*WorkflowLogic, *gorm.DB) error
}

// DefaultStrictUpdateWorkflowLogic clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkflowLogic(ctx context.Context, in *WorkflowLogic, db *gorm.DB) (*WorkflowLogic, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkflowLogic")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkflowLogicORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("WorkflowLogicID=?", ormObj.WorkflowLogicID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Model(&ormObj).Association("Requirements").Append(ormObj.Requirements).Error; err != nil {
		return nil, err
	}
	ormObj.Requirements = nil
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkflowLogicORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkflowLogic executes a basic gorm update call with patch behavior
func DefaultPatchWorkflowLogic(ctx context.Context, in *WorkflowLogic, updateMask *field_mask.FieldMask, db *gorm.DB) (*WorkflowLogic, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj WorkflowLogic
	var err error
	if hook, ok := interface{}(&pbObj).(WorkflowLogicWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(WorkflowLogicWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkflowLogic(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkflowLogicWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkflowLogic(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkflowLogicWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkflowLogicWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *WorkflowLogic, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *WorkflowLogic, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *WorkflowLogic, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *WorkflowLogic, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkflowLogic executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkflowLogic(ctx context.Context, objects []*WorkflowLogic, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*WorkflowLogic, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*WorkflowLogic, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkflowLogic(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkflowLogic patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkflowLogic(ctx context.Context, patchee *WorkflowLogic, patcher *WorkflowLogic, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*WorkflowLogic, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"WorkflowLogicID" {
			patchee.WorkflowLogicID = patcher.WorkflowLogicID
			continue
		}
		if f == prefix+"WorkflowID" {
			patchee.WorkflowID = patcher.WorkflowID
			continue
		}
		if f == prefix+"BottomRange" {
			patchee.BottomRange = patcher.BottomRange
			continue
		}
		if f == prefix+"TopRange" {
			patchee.TopRange = patcher.TopRange
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Requirements" {
			patchee.Requirements = patcher.Requirements
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkflowLogic executes a gorm list call
func DefaultListWorkflowLogic(ctx context.Context, db *gorm.DB) ([]*WorkflowLogic, error) {
	in := WorkflowLogic{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &WorkflowLogicORM{}, &WorkflowLogic{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("WorkflowLogicID")
	ormResponse := []WorkflowLogicORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowLogicORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*WorkflowLogic{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkflowLogicORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowLogicORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkflowLogicORM) error
}

// DefaultCreateWorkflowRequirement executes a basic gorm create call
func DefaultCreateWorkflowRequirement(ctx context.Context, in *WorkflowRequirement, db *gorm.DB) (*WorkflowRequirement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type WorkflowRequirementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadWorkflowRequirement(ctx context.Context, in *WorkflowRequirement, db *gorm.DB) (*WorkflowRequirement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.WorkflowRequirementID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &WorkflowRequirementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := WorkflowRequirementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(WorkflowRequirementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type WorkflowRequirementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkflowRequirement(ctx context.Context, in *WorkflowRequirement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.WorkflowRequirementID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&WorkflowRequirementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type WorkflowRequirementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteWorkflowRequirementSet(ctx context.Context, in []*WorkflowRequirement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.WorkflowRequirementID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.WorkflowRequirementID)
	}
	if hook, ok := (interface{}(&WorkflowRequirementORM{})).(WorkflowRequirementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("workflow_requirement_id in (?)", keys).Delete(&WorkflowRequirementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&WorkflowRequirementORM{})).(WorkflowRequirementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type WorkflowRequirementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*WorkflowRequirement, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*WorkflowRequirement, *gorm.DB) error
}

// DefaultStrictUpdateWorkflowRequirement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateWorkflowRequirement(ctx context.Context, in *WorkflowRequirement, db *gorm.DB) (*WorkflowRequirement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateWorkflowRequirement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &WorkflowRequirementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("WorkflowRequirementID=?", ormObj.WorkflowRequirementID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type WorkflowRequirementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchWorkflowRequirement executes a basic gorm update call with patch behavior
func DefaultPatchWorkflowRequirement(ctx context.Context, in *WorkflowRequirement, updateMask *field_mask.FieldMask, db *gorm.DB) (*WorkflowRequirement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj WorkflowRequirement
	var err error
	if hook, ok := interface{}(&pbObj).(WorkflowRequirementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(WorkflowRequirementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskWorkflowRequirement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(WorkflowRequirementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateWorkflowRequirement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(WorkflowRequirementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type WorkflowRequirementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *WorkflowRequirement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *WorkflowRequirement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *WorkflowRequirement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *WorkflowRequirement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetWorkflowRequirement executes a bulk gorm update call with patch behavior
func DefaultPatchSetWorkflowRequirement(ctx context.Context, objects []*WorkflowRequirement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*WorkflowRequirement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*WorkflowRequirement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchWorkflowRequirement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskWorkflowRequirement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskWorkflowRequirement(ctx context.Context, patchee *WorkflowRequirement, patcher *WorkflowRequirement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*WorkflowRequirement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"WorkflowRequirementID" {
			patchee.WorkflowRequirementID = patcher.WorkflowRequirementID
			continue
		}
		if f == prefix+"WorkflowLogicID" {
			patchee.WorkflowLogicID = patcher.WorkflowLogicID
			continue
		}
		if f == prefix+"Step" {
			patchee.Step = patcher.Step
			continue
		}
		if f == prefix+"RoleID" {
			patchee.RoleID = patcher.RoleID
			continue
		}
		if f == prefix+"Priority" {
			patchee.Priority = patcher.Priority
			continue
		}
		if f == prefix+"MinimumNumber" {
			patchee.MinimumNumber = patcher.MinimumNumber
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListWorkflowRequirement executes a gorm list call
func DefaultListWorkflowRequirement(ctx context.Context, db *gorm.DB) ([]*WorkflowRequirement, error) {
	in := WorkflowRequirement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &WorkflowRequirementORM{}, &WorkflowRequirement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("WorkflowRequirementID")
	ormResponse := []WorkflowRequirementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(WorkflowRequirementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*WorkflowRequirement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type WorkflowRequirementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type WorkflowRequirementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]WorkflowRequirementORM) error
}

// DefaultCreateCompanyWorkflows executes a basic gorm create call
func DefaultCreateCompanyWorkflows(ctx context.Context, in *CompanyWorkflows, db *gorm.DB) (*CompanyWorkflows, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyWorkflowsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyWorkflows(ctx context.Context, in *CompanyWorkflows, db *gorm.DB) (*CompanyWorkflows, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.WorkflowCompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyWorkflowsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyWorkflowsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyWorkflowsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyWorkflowsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyWorkflows(ctx context.Context, in *CompanyWorkflows, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.WorkflowCompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyWorkflowsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyWorkflowsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyWorkflowsSet(ctx context.Context, in []*CompanyWorkflows, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.WorkflowCompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.WorkflowCompanyID)
	}
	if hook, ok := (interface{}(&CompanyWorkflowsORM{})).(CompanyWorkflowsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("workflow_company_id in (?)", keys).Delete(&CompanyWorkflowsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyWorkflowsORM{})).(CompanyWorkflowsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyWorkflowsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyWorkflows, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyWorkflows, *gorm.DB) error
}

// DefaultStrictUpdateCompanyWorkflows clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyWorkflows(ctx context.Context, in *CompanyWorkflows, db *gorm.DB) (*CompanyWorkflows, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyWorkflows")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyWorkflowsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("WorkflowCompanyID=?", ormObj.WorkflowCompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyWorkflowsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyWorkflows executes a basic gorm update call with patch behavior
func DefaultPatchCompanyWorkflows(ctx context.Context, in *CompanyWorkflows, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyWorkflows, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyWorkflows
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyWorkflowsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyWorkflowsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyWorkflows(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyWorkflowsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyWorkflows(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyWorkflowsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyWorkflowsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyWorkflows, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyWorkflows, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyWorkflows, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyWorkflows, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyWorkflows executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyWorkflows(ctx context.Context, objects []*CompanyWorkflows, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyWorkflows, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyWorkflows, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyWorkflows(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyWorkflows patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyWorkflows(ctx context.Context, patchee *CompanyWorkflows, patcher *CompanyWorkflows, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyWorkflows, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"WorkflowCompanyID" {
			patchee.WorkflowCompanyID = patcher.WorkflowCompanyID
			continue
		}
		if f == prefix+"IsTransactionSTP" {
			patchee.IsTransactionSTP = patcher.IsTransactionSTP
			continue
		}
		if f == prefix+"IsTransactionChecker" {
			patchee.IsTransactionChecker = patcher.IsTransactionChecker
			continue
		}
		if f == prefix+"IsTransactionSigner" {
			patchee.IsTransactionSigner = patcher.IsTransactionSigner
			continue
		}
		if f == prefix+"IsTransactionReleaser" {
			patchee.IsTransactionReleaser = patcher.IsTransactionReleaser
			continue
		}
		if f == prefix+"IsNonTransactionSTP" {
			patchee.IsNonTransactionSTP = patcher.IsNonTransactionSTP
			continue
		}
		if f == prefix+"IsNonTransactionChecker" {
			patchee.IsNonTransactionChecker = patcher.IsNonTransactionChecker
			continue
		}
		if f == prefix+"IsNonTransactionSigner" {
			patchee.IsNonTransactionSigner = patcher.IsNonTransactionSigner
			continue
		}
		if f == prefix+"IsNonTransactionReleaser" {
			patchee.IsNonTransactionReleaser = patcher.IsNonTransactionReleaser
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyWorkflows executes a gorm list call
func DefaultListCompanyWorkflows(ctx context.Context, db *gorm.DB) ([]*CompanyWorkflows, error) {
	in := CompanyWorkflows{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyWorkflowsORM{}, &CompanyWorkflows{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("WorkflowCompanyID")
	ormResponse := []CompanyWorkflowsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyWorkflowsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyWorkflows{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyWorkflowsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyWorkflowsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyWorkflowsORM) error
}
