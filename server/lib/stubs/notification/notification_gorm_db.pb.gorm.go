package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserORM struct {
	CreatedAt *time.Time
	DeletedAt *time.Time
	Id        uint64 `gorm:"primary_key;not null"`
	Password  string `gorm:"not null"`
	Role      string `gorm:"default:user;not null"`
	UpdatedAt *time.Time
	Username  string `gorm:"unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type NotificationModuleORM struct {
	CreatedAt       *time.Time
	DeletedAt       *time.Time
	ModuleEvents    []*ModuleEventORM    `gorm:"foreignkey:NotificationModuleModuleID;association_foreignkey:ModuleID"`
	ModuleID        uint64               `gorm:"primary_key;not null"`
	ModuleVariables []*ModuleVariableORM `gorm:"foreignkey:NotificationModuleModuleID;association_foreignkey:ModuleID"`
	Name            string               `gorm:"type:varchar(255)"`
	UpdatedAt       *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationModuleORM) TableName() string {
	return "notification_modules"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationModule) ToORM(ctx context.Context) (NotificationModuleORM, error) {
	to := NotificationModuleORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationModuleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ModuleID = m.ModuleID
	to.Name = m.Name
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.ModuleEvents {
		if v != nil {
			if tempModuleEvents, cErr := v.ToORM(ctx); cErr == nil {
				to.ModuleEvents = append(to.ModuleEvents, &tempModuleEvents)
			} else {
				return to, cErr
			}
		} else {
			to.ModuleEvents = append(to.ModuleEvents, nil)
		}
	}
	for _, v := range m.ModuleVariables {
		if v != nil {
			if tempModuleVariables, cErr := v.ToORM(ctx); cErr == nil {
				to.ModuleVariables = append(to.ModuleVariables, &tempModuleVariables)
			} else {
				return to, cErr
			}
		} else {
			to.ModuleVariables = append(to.ModuleVariables, nil)
		}
	}
	if posthook, ok := interface{}(m).(NotificationModuleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationModuleORM) ToPB(ctx context.Context) (NotificationModule, error) {
	to := NotificationModule{}
	var err error
	if prehook, ok := interface{}(m).(NotificationModuleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ModuleID = m.ModuleID
	to.Name = m.Name
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.ModuleEvents {
		if v != nil {
			if tempModuleEvents, cErr := v.ToPB(ctx); cErr == nil {
				to.ModuleEvents = append(to.ModuleEvents, &tempModuleEvents)
			} else {
				return to, cErr
			}
		} else {
			to.ModuleEvents = append(to.ModuleEvents, nil)
		}
	}
	for _, v := range m.ModuleVariables {
		if v != nil {
			if tempModuleVariables, cErr := v.ToPB(ctx); cErr == nil {
				to.ModuleVariables = append(to.ModuleVariables, &tempModuleVariables)
			} else {
				return to, cErr
			}
		} else {
			to.ModuleVariables = append(to.ModuleVariables, nil)
		}
	}
	if posthook, ok := interface{}(m).(NotificationModuleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationModule the arg will be the target, the caller the one being converted from

// NotificationModuleBeforeToORM called before default ToORM code
type NotificationModuleWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationModuleORM) error
}

// NotificationModuleAfterToORM called after default ToORM code
type NotificationModuleWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationModuleORM) error
}

// NotificationModuleBeforeToPB called before default ToPB code
type NotificationModuleWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationModule) error
}

// NotificationModuleAfterToPB called after default ToPB code
type NotificationModuleWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationModule) error
}

type ModuleEventORM struct {
	CreatedAt                  *time.Time
	DeletedAt                  *time.Time
	EventID                    uint64                 `gorm:"primary_key;not null"`
	EventVariables             []*EventVariableORM    `gorm:"foreignkey:ModuleEventEventID;association_foreignkey:EventID"`
	Module                     *NotificationModuleORM `gorm:"foreignkey:NotificationModuleModuleID;association_foreignkey:ModuleID"`
	Name                       string                 `gorm:"type:varchar(255)"`
	NotificationModuleModuleID *uint64
	NotificationModuleModuleId uint64
	Notify                     string `gorm:"type:varchar(20)"`
	TemplateDescription        string `gorm:"type:text"`
	TemplateTitle              string `gorm:"type:text"`
	UpdatedAt                  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ModuleEventORM) TableName() string {
	return "module_events"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ModuleEvent) ToORM(ctx context.Context) (ModuleEventORM, error) {
	to := ModuleEventORM{}
	var err error
	if prehook, ok := interface{}(m).(ModuleEventWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EventID = m.EventID
	if m.Module != nil {
		tempModule, err := m.Module.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Module = &tempModule
	}
	to.Name = m.Name
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	for _, v := range m.EventVariables {
		if v != nil {
			if tempEventVariables, cErr := v.ToORM(ctx); cErr == nil {
				to.EventVariables = append(to.EventVariables, &tempEventVariables)
			} else {
				return to, cErr
			}
		} else {
			to.EventVariables = append(to.EventVariables, nil)
		}
	}
	to.Notify = m.Notify
	to.TemplateTitle = m.TemplateTitle
	to.TemplateDescription = m.TemplateDescription
	to.NotificationModuleModuleId = m.NotificationModuleModuleId
	if posthook, ok := interface{}(m).(ModuleEventWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ModuleEventORM) ToPB(ctx context.Context) (ModuleEvent, error) {
	to := ModuleEvent{}
	var err error
	if prehook, ok := interface{}(m).(ModuleEventWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EventID = m.EventID
	if m.Module != nil {
		tempModule, err := m.Module.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Module = &tempModule
	}
	to.Name = m.Name
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	for _, v := range m.EventVariables {
		if v != nil {
			if tempEventVariables, cErr := v.ToPB(ctx); cErr == nil {
				to.EventVariables = append(to.EventVariables, &tempEventVariables)
			} else {
				return to, cErr
			}
		} else {
			to.EventVariables = append(to.EventVariables, nil)
		}
	}
	to.Notify = m.Notify
	to.TemplateTitle = m.TemplateTitle
	to.TemplateDescription = m.TemplateDescription
	to.NotificationModuleModuleId = m.NotificationModuleModuleId
	if posthook, ok := interface{}(m).(ModuleEventWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ModuleEvent the arg will be the target, the caller the one being converted from

// ModuleEventBeforeToORM called before default ToORM code
type ModuleEventWithBeforeToORM interface {
	BeforeToORM(context.Context, *ModuleEventORM) error
}

// ModuleEventAfterToORM called after default ToORM code
type ModuleEventWithAfterToORM interface {
	AfterToORM(context.Context, *ModuleEventORM) error
}

// ModuleEventBeforeToPB called before default ToPB code
type ModuleEventWithBeforeToPB interface {
	BeforeToPB(context.Context, *ModuleEvent) error
}

// ModuleEventAfterToPB called after default ToPB code
type ModuleEventWithAfterToPB interface {
	AfterToPB(context.Context, *ModuleEvent) error
}

type ModuleVariableORM struct {
	CreatedAt                  *time.Time
	DeletedAt                  *time.Time
	Module                     *NotificationModuleORM `gorm:"foreignkey:NotificationModuleModuleID;association_foreignkey:ModuleID"`
	Name                       string                 `gorm:"type:varchar(255)"`
	NotificationModuleModuleID *uint64
	UpdatedAt                  *time.Time
	VariableID                 uint64 `gorm:"primary_key;not null"`
}

// TableName overrides the default tablename generated by GORM
func (ModuleVariableORM) TableName() string {
	return "module_variables"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ModuleVariable) ToORM(ctx context.Context) (ModuleVariableORM, error) {
	to := ModuleVariableORM{}
	var err error
	if prehook, ok := interface{}(m).(ModuleVariableWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.VariableID = m.VariableID
	if m.Module != nil {
		tempModule, err := m.Module.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Module = &tempModule
	}
	to.Name = m.Name
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(ModuleVariableWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ModuleVariableORM) ToPB(ctx context.Context) (ModuleVariable, error) {
	to := ModuleVariable{}
	var err error
	if prehook, ok := interface{}(m).(ModuleVariableWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.VariableID = m.VariableID
	if m.Module != nil {
		tempModule, err := m.Module.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Module = &tempModule
	}
	to.Name = m.Name
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(ModuleVariableWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ModuleVariable the arg will be the target, the caller the one being converted from

// ModuleVariableBeforeToORM called before default ToORM code
type ModuleVariableWithBeforeToORM interface {
	BeforeToORM(context.Context, *ModuleVariableORM) error
}

// ModuleVariableAfterToORM called after default ToORM code
type ModuleVariableWithAfterToORM interface {
	AfterToORM(context.Context, *ModuleVariableORM) error
}

// ModuleVariableBeforeToPB called before default ToPB code
type ModuleVariableWithBeforeToPB interface {
	BeforeToPB(context.Context, *ModuleVariable) error
}

// ModuleVariableAfterToPB called after default ToPB code
type ModuleVariableWithAfterToPB interface {
	AfterToPB(context.Context, *ModuleVariable) error
}

type EventVariableORM struct {
	ColumnName         string `gorm:"type:varchar(255)"`
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	Event              *ModuleEventORM `gorm:"foreignkey:ModuleEventEventID;association_foreignkey:EventID"`
	ModuleEventEventID *uint64
	Name               string `gorm:"type:varchar(255)"`
	Table              string `gorm:"type:varchar(255)"`
	UpdatedAt          *time.Time
	VariableID         uint64 `gorm:"primary_key;not null"`
}

// TableName overrides the default tablename generated by GORM
func (EventVariableORM) TableName() string {
	return "event_variables"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EventVariable) ToORM(ctx context.Context) (EventVariableORM, error) {
	to := EventVariableORM{}
	var err error
	if prehook, ok := interface{}(m).(EventVariableWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.VariableID = m.VariableID
	if m.Event != nil {
		tempEvent, err := m.Event.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.Name = m.Name
	to.Table = m.Table
	to.ColumnName = m.ColumnName
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(EventVariableWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EventVariableORM) ToPB(ctx context.Context) (EventVariable, error) {
	to := EventVariable{}
	var err error
	if prehook, ok := interface{}(m).(EventVariableWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.VariableID = m.VariableID
	if m.Event != nil {
		tempEvent, err := m.Event.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.Name = m.Name
	to.Table = m.Table
	to.ColumnName = m.ColumnName
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(EventVariableWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EventVariable the arg will be the target, the caller the one being converted from

// EventVariableBeforeToORM called before default ToORM code
type EventVariableWithBeforeToORM interface {
	BeforeToORM(context.Context, *EventVariableORM) error
}

// EventVariableAfterToORM called after default ToORM code
type EventVariableWithAfterToORM interface {
	AfterToORM(context.Context, *EventVariableORM) error
}

// EventVariableBeforeToPB called before default ToPB code
type EventVariableWithBeforeToPB interface {
	BeforeToPB(context.Context, *EventVariable) error
}

// EventVariableAfterToPB called after default ToPB code
type EventVariableWithAfterToPB interface {
	AfterToPB(context.Context, *EventVariable) error
}

type NotificationORM struct {
	AllCompany             bool
	Code                   string `gorm:"type:varchar(255)"`
	CreatedAt              *time.Time
	CreatedByID            uint64
	DeletedAt              *time.Time
	DeletedByID            uint64
	Description            string `gorm:"type:varchar(255)"`
	EndAt                  *time.Time
	Event                  *ModuleEventORM `gorm:"foreignkey:ModuleEventEventID;association_foreignkey:EventID"`
	EventID                uint64          `gorm:"column:module_event_event_id"`
	ModuleEventEventID     *uint64
	ModuleName             string
	NotificationEmail      *NotificationEmailORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationID         uint64                `gorm:"primary_key;not null"`
	NotificationSms        *NotificationSMSORM   `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationTaskTaskID *uint64
	StartAt                *time.Time
	Title                  string `gorm:"type:varchar(255)"`
	UpdatedAt              *time.Time
	UpdatedByID            uint64
	UserID                 uint64 `gorm:"column:user_id"`
}

// TableName overrides the default tablename generated by GORM
func (NotificationORM) TableName() string {
	return "notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Notification) ToORM(ctx context.Context) (NotificationORM, error) {
	to := NotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationID = m.NotificationID
	if m.Event != nil {
		tempEvent, err := m.Event.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.EventID = m.EventID
	to.Code = m.Code
	to.Description = m.Description
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	if m.NotificationSms != nil {
		tempNotificationSms, err := m.NotificationSms.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSms = &tempNotificationSms
	}
	if m.NotificationEmail != nil {
		tempNotificationEmail, err := m.NotificationEmail.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationEmail = &tempNotificationEmail
	}
	if m.StartAt != nil {
		t := m.StartAt.AsTime()
		to.StartAt = &t
	}
	if m.EndAt != nil {
		t := m.EndAt.AsTime()
		to.EndAt = &t
	}
	to.AllCompany = m.AllCompany
	to.UserID = m.UserID
	to.Title = m.Title
	to.ModuleName = m.ModuleName
	if posthook, ok := interface{}(m).(NotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationORM) ToPB(ctx context.Context) (Notification, error) {
	to := Notification{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationID = m.NotificationID
	if m.Event != nil {
		tempEvent, err := m.Event.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Event = &tempEvent
	}
	to.EventID = m.EventID
	to.Code = m.Code
	to.Description = m.Description
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	if m.NotificationSms != nil {
		tempNotificationSms, err := m.NotificationSms.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSms = &tempNotificationSms
	}
	if m.NotificationEmail != nil {
		tempNotificationEmail, err := m.NotificationEmail.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationEmail = &tempNotificationEmail
	}
	if m.StartAt != nil {
		to.StartAt = timestamppb.New(*m.StartAt)
	}
	if m.EndAt != nil {
		to.EndAt = timestamppb.New(*m.EndAt)
	}
	to.AllCompany = m.AllCompany
	to.UserID = m.UserID
	to.Title = m.Title
	to.ModuleName = m.ModuleName
	if posthook, ok := interface{}(m).(NotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Notification the arg will be the target, the caller the one being converted from

// NotificationBeforeToORM called before default ToORM code
type NotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationORM) error
}

// NotificationAfterToORM called after default ToORM code
type NotificationWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationORM) error
}

// NotificationBeforeToPB called before default ToPB code
type NotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Notification) error
}

// NotificationAfterToPB called after default ToPB code
type NotificationWithAfterToPB interface {
	AfterToPB(context.Context, *Notification) error
}

type NotificationFCMORM struct {
	CreatedAt      *time.Time
	CreatedByID    uint64
	DeletedAt      *time.Time
	DeletedByID    uint64
	Description    string `gorm:"type:varchar(255)"`
	IsRead         bool
	ModuleID       uint64
	ModuleName     string
	NotificationID uint64 `gorm:"primary_key;not null"`
	Times          string
	Title          string `gorm:"type:varchar(255)"`
	UpdatedAt      *time.Time
	UpdatedByID    uint64
	UserID         uint64 `gorm:"column:user_id"`
}

// TableName overrides the default tablename generated by GORM
func (NotificationFCMORM) TableName() string {
	return "notification_fcms"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationFCM) ToORM(ctx context.Context) (NotificationFCMORM, error) {
	to := NotificationFCMORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationFCMWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationID = m.NotificationID
	to.UserID = m.UserID
	to.Title = m.Title
	to.Description = m.Description
	to.ModuleID = m.ModuleID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	to.ModuleName = m.ModuleName
	to.Times = m.Times
	to.IsRead = m.IsRead
	if posthook, ok := interface{}(m).(NotificationFCMWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationFCMORM) ToPB(ctx context.Context) (NotificationFCM, error) {
	to := NotificationFCM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationFCMWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationID = m.NotificationID
	to.UserID = m.UserID
	to.Title = m.Title
	to.Description = m.Description
	to.ModuleID = m.ModuleID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	to.ModuleName = m.ModuleName
	to.Times = m.Times
	to.IsRead = m.IsRead
	if posthook, ok := interface{}(m).(NotificationFCMWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationFCM the arg will be the target, the caller the one being converted from

// NotificationFCMBeforeToORM called before default ToORM code
type NotificationFCMWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationFCMORM) error
}

// NotificationFCMAfterToORM called after default ToORM code
type NotificationFCMWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationFCMORM) error
}

// NotificationFCMBeforeToPB called before default ToPB code
type NotificationFCMWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationFCM) error
}

// NotificationFCMAfterToPB called after default ToPB code
type NotificationFCMWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationFCM) error
}

type NotificationCompanyORM struct {
	CompanyID                  uint64
	CreatedAt                  *time.Time
	DeletedAt                  *time.Time
	Name                       string           `gorm:"type:varchar(255)"`
	Notification               *NotificationORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationCompanyID      uint64           `gorm:"primary_key;not null"`
	NotificationNotificationID *uint64
	UpdatedAt                  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationCompanyORM) TableName() string {
	return "notification_company"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationCompany) ToORM(ctx context.Context) (NotificationCompanyORM, error) {
	to := NotificationCompanyORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationCompanyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationCompanyID = m.NotificationCompanyID
	to.CompanyID = m.CompanyID
	to.Name = m.Name
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(NotificationCompanyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationCompanyORM) ToPB(ctx context.Context) (NotificationCompany, error) {
	to := NotificationCompany{}
	var err error
	if prehook, ok := interface{}(m).(NotificationCompanyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.NotificationCompanyID = m.NotificationCompanyID
	to.CompanyID = m.CompanyID
	to.Name = m.Name
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(NotificationCompanyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationCompany the arg will be the target, the caller the one being converted from

// NotificationCompanyBeforeToORM called before default ToORM code
type NotificationCompanyWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationCompanyORM) error
}

// NotificationCompanyAfterToORM called after default ToORM code
type NotificationCompanyWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationCompanyORM) error
}

// NotificationCompanyBeforeToPB called before default ToPB code
type NotificationCompanyWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationCompany) error
}

// NotificationCompanyAfterToPB called after default ToPB code
type NotificationCompanyWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationCompany) error
}

type NotificationTaskORM struct {
	Notification   *NotificationORM `gorm:"foreignkey:NotificationTaskTaskID;association_foreignkey:TaskID"`
	NotificationID uint64           `gorm:"column:NotificationID;not null"`
	TaskID         uint64           `gorm:"column:TaskID;primary_key;not null"`
}

// TableName overrides the default tablename generated by GORM
func (NotificationTaskORM) TableName() string {
	return "notification_tasks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationTask) ToORM(ctx context.Context) (NotificationTaskORM, error) {
	to := NotificationTaskORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationTaskWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TaskID = m.TaskID
	to.NotificationID = m.NotificationID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	if posthook, ok := interface{}(m).(NotificationTaskWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationTaskORM) ToPB(ctx context.Context) (NotificationTask, error) {
	to := NotificationTask{}
	var err error
	if prehook, ok := interface{}(m).(NotificationTaskWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TaskID = m.TaskID
	to.NotificationID = m.NotificationID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	if posthook, ok := interface{}(m).(NotificationTaskWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationTask the arg will be the target, the caller the one being converted from

// NotificationTaskBeforeToORM called before default ToORM code
type NotificationTaskWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationTaskORM) error
}

// NotificationTaskAfterToORM called after default ToORM code
type NotificationTaskWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationTaskORM) error
}

// NotificationTaskBeforeToPB called before default ToPB code
type NotificationTaskWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationTask) error
}

// NotificationTaskAfterToPB called after default ToPB code
type NotificationTaskWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationTask) error
}

type NotificationSMSORM struct {
	Content                    string `gorm:"type:text"`
	CreatedAt                  *time.Time
	CreatedByID                uint64
	DeletedAt                  *time.Time
	DeletedByID                uint64
	Notification               *NotificationORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationNotificationID *uint64
	PhoneNumber                string `gorm:"type:text"`
	Produk                     string `gorm:"type:text"`
	Rekening                   string `gorm:"type:varchar(255)"`
	SmsDeliveryID              uint64 `gorm:"primary_key;not null"`
	UpdatedAt                  *time.Time
	UpdatedByID                uint64
}

// TableName overrides the default tablename generated by GORM
func (NotificationSMSORM) TableName() string {
	return "notification_sms"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationSMS) ToORM(ctx context.Context) (NotificationSMSORM, error) {
	to := NotificationSMSORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSMSWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SmsDeliveryID = m.SmsDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Rekening = m.Rekening
	to.Produk = m.Produk
	to.PhoneNumber = m.PhoneNumber
	to.Content = m.Content
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(NotificationSMSWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationSMSORM) ToPB(ctx context.Context) (NotificationSMS, error) {
	to := NotificationSMS{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSMSWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SmsDeliveryID = m.SmsDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Rekening = m.Rekening
	to.Produk = m.Produk
	to.PhoneNumber = m.PhoneNumber
	to.Content = m.Content
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(NotificationSMSWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationSMS the arg will be the target, the caller the one being converted from

// NotificationSMSBeforeToORM called before default ToORM code
type NotificationSMSWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationSMSORM) error
}

// NotificationSMSAfterToORM called after default ToORM code
type NotificationSMSWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationSMSORM) error
}

// NotificationSMSBeforeToPB called before default ToPB code
type NotificationSMSWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationSMS) error
}

// NotificationSMSAfterToPB called after default ToPB code
type NotificationSMSWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationSMS) error
}

type NotificationEmailORM struct {
	Body                       string `gorm:"type:text"`
	CreatedAt                  *time.Time
	CreatedByID                uint64
	DeletedAt                  *time.Time
	DeletedByID                uint64
	EmailCc                    string           `gorm:"type:text"`
	EmailDeliveryID            uint64           `gorm:"primary_key;not null"`
	EmailTo                    string           `gorm:"type:text"`
	Notification               *NotificationORM `gorm:"foreignkey:NotificationNotificationID;association_foreignkey:NotificationID"`
	NotificationNotificationID *uint64
	Produk                     string `gorm:"type:text"`
	Subject                    string `gorm:"type:text"`
	UpdatedAt                  *time.Time
	UpdatedByID                uint64
}

// TableName overrides the default tablename generated by GORM
func (NotificationEmailORM) TableName() string {
	return "notification_emails"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationEmail) ToORM(ctx context.Context) (NotificationEmailORM, error) {
	to := NotificationEmailORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationEmailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EmailDeliveryID = m.EmailDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Produk = m.Produk
	to.EmailTo = m.EmailTo
	to.EmailCc = m.EmailCc
	to.Subject = m.Subject
	to.Body = m.Body
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(NotificationEmailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationEmailORM) ToPB(ctx context.Context) (NotificationEmail, error) {
	to := NotificationEmail{}
	var err error
	if prehook, ok := interface{}(m).(NotificationEmailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.EmailDeliveryID = m.EmailDeliveryID
	if m.Notification != nil {
		tempNotification, err := m.Notification.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notification = &tempNotification
	}
	to.Produk = m.Produk
	to.EmailTo = m.EmailTo
	to.EmailCc = m.EmailCc
	to.Subject = m.Subject
	to.Body = m.Body
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(NotificationEmailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationEmail the arg will be the target, the caller the one being converted from

// NotificationEmailBeforeToORM called before default ToORM code
type NotificationEmailWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationEmailORM) error
}

// NotificationEmailAfterToORM called after default ToORM code
type NotificationEmailWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationEmailORM) error
}

// NotificationEmailBeforeToPB called before default ToPB code
type NotificationEmailWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationEmail) error
}

// NotificationEmailAfterToPB called after default ToPB code
type NotificationEmailWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationEmail) error
}

type TempClientORM struct {
	ClientID uint64 `gorm:"column:ClientID;primary_key;not null"`
	Email    string `gorm:"column:Email"`
	Name     string `gorm:"column:Name"`
	Phone    string `gorm:"column:Phone"`
}

// TableName overrides the default tablename generated by GORM
func (TempClientORM) TableName() string {
	return "temp_clients"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TempClient) ToORM(ctx context.Context) (TempClientORM, error) {
	to := TempClientORM{}
	var err error
	if prehook, ok := interface{}(m).(TempClientWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ClientID = m.ClientID
	to.Name = m.Name
	to.Email = m.Email
	to.Phone = m.Phone
	if posthook, ok := interface{}(m).(TempClientWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TempClientORM) ToPB(ctx context.Context) (TempClient, error) {
	to := TempClient{}
	var err error
	if prehook, ok := interface{}(m).(TempClientWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ClientID = m.ClientID
	to.Name = m.Name
	to.Email = m.Email
	to.Phone = m.Phone
	if posthook, ok := interface{}(m).(TempClientWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TempClient the arg will be the target, the caller the one being converted from

// TempClientBeforeToORM called before default ToORM code
type TempClientWithBeforeToORM interface {
	BeforeToORM(context.Context, *TempClientORM) error
}

// TempClientAfterToORM called after default ToORM code
type TempClientWithAfterToORM interface {
	AfterToORM(context.Context, *TempClientORM) error
}

// TempClientBeforeToPB called before default ToPB code
type TempClientWithBeforeToPB interface {
	BeforeToPB(context.Context, *TempClient) error
}

// TempClientAfterToPB called after default ToPB code
type TempClientWithAfterToPB interface {
	AfterToPB(context.Context, *TempClient) error
}

type DefaultNotificationsORM struct {
	CreatedAt *time.Time
	DefaultID uint64 `gorm:"primary_key;not null"`
	DeletedAt *time.Time
	EventName string `gorm:"type:varchar(255)"`
	Message   string `gorm:"type:text"`
	Title     string `gorm:"type:varchar(255)"`
	UpdatedAt *time.Time
}

// TableName overrides the default tablename generated by GORM
func (DefaultNotificationsORM) TableName() string {
	return "default_notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DefaultNotifications) ToORM(ctx context.Context) (DefaultNotificationsORM, error) {
	to := DefaultNotificationsORM{}
	var err error
	if prehook, ok := interface{}(m).(DefaultNotificationsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.DefaultID = m.DefaultID
	to.EventName = m.EventName
	to.Title = m.Title
	to.Message = m.Message
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(DefaultNotificationsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DefaultNotificationsORM) ToPB(ctx context.Context) (DefaultNotifications, error) {
	to := DefaultNotifications{}
	var err error
	if prehook, ok := interface{}(m).(DefaultNotificationsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.DefaultID = m.DefaultID
	to.EventName = m.EventName
	to.Title = m.Title
	to.Message = m.Message
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(DefaultNotificationsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DefaultNotifications the arg will be the target, the caller the one being converted from

// DefaultNotificationsBeforeToORM called before default ToORM code
type DefaultNotificationsWithBeforeToORM interface {
	BeforeToORM(context.Context, *DefaultNotificationsORM) error
}

// DefaultNotificationsAfterToORM called after default ToORM code
type DefaultNotificationsWithAfterToORM interface {
	AfterToORM(context.Context, *DefaultNotificationsORM) error
}

// DefaultNotificationsBeforeToPB called before default ToPB code
type DefaultNotificationsWithBeforeToPB interface {
	BeforeToPB(context.Context, *DefaultNotifications) error
}

// DefaultNotificationsAfterToPB called after default ToPB code
type DefaultNotificationsWithAfterToPB interface {
	AfterToPB(context.Context, *DefaultNotifications) error
}

type NotificationEmailTemplateORM struct {
	Id    uint64 `gorm:"primary_key;not null"`
	Key   string `gorm:"not null"`
	Value string `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (NotificationEmailTemplateORM) TableName() string {
	return "notification_emails_template"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationEmailTemplate) ToORM(ctx context.Context) (NotificationEmailTemplateORM, error) {
	to := NotificationEmailTemplateORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationEmailTemplateWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Key = m.Key
	to.Value = m.Value
	if posthook, ok := interface{}(m).(NotificationEmailTemplateWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationEmailTemplateORM) ToPB(ctx context.Context) (NotificationEmailTemplate, error) {
	to := NotificationEmailTemplate{}
	var err error
	if prehook, ok := interface{}(m).(NotificationEmailTemplateWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Key = m.Key
	to.Value = m.Value
	if posthook, ok := interface{}(m).(NotificationEmailTemplateWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationEmailTemplate the arg will be the target, the caller the one being converted from

// NotificationEmailTemplateBeforeToORM called before default ToORM code
type NotificationEmailTemplateWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationEmailTemplateORM) error
}

// NotificationEmailTemplateAfterToORM called after default ToORM code
type NotificationEmailTemplateWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationEmailTemplateORM) error
}

// NotificationEmailTemplateBeforeToPB called before default ToPB code
type NotificationEmailTemplateWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationEmailTemplate) error
}

// NotificationEmailTemplateAfterToPB called after default ToPB code
type NotificationEmailTemplateWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationEmailTemplate) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateNotificationModule executes a basic gorm create call
func DefaultCreateNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationModuleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.ModuleID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationModuleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationModuleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationModuleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationModuleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.ModuleID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationModuleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationModuleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationModuleSet(ctx context.Context, in []*NotificationModule, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.ModuleID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.ModuleID)
	}
	if hook, ok := (interface{}(&NotificationModuleORM{})).(NotificationModuleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("module_id in (?)", keys).Delete(&NotificationModuleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationModuleORM{})).(NotificationModuleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationModuleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationModule, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationModule, *gorm.DB) error
}

// DefaultStrictUpdateNotificationModule clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationModule(ctx context.Context, in *NotificationModule, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationModule")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationModuleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("module_id=?", ormObj.ModuleID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterModuleEvents := ModuleEventORM{}
	if ormObj.ModuleID == 0 {
		return nil, errors.EmptyIdError
	}
	filterModuleEvents.NotificationModuleModuleID = new(uint64)
	*filterModuleEvents.NotificationModuleModuleID = ormObj.ModuleID
	if err = db.Where(filterModuleEvents).Delete(ModuleEventORM{}).Error; err != nil {
		return nil, err
	}
	filterModuleVariables := ModuleVariableORM{}
	if ormObj.ModuleID == 0 {
		return nil, errors.EmptyIdError
	}
	filterModuleVariables.NotificationModuleModuleID = new(uint64)
	*filterModuleVariables.NotificationModuleModuleID = ormObj.ModuleID
	if err = db.Where(filterModuleVariables).Delete(ModuleVariableORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationModuleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationModule executes a basic gorm update call with patch behavior
func DefaultPatchNotificationModule(ctx context.Context, in *NotificationModule, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationModule, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationModule
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationModuleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationModuleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationModule(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationModuleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationModule(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationModuleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationModuleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationModule, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationModule executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationModule(ctx context.Context, objects []*NotificationModule, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationModule, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationModule, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationModule(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationModule patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationModule(ctx context.Context, patchee *NotificationModule, patcher *NotificationModule, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationModule, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"ModuleID" {
			patchee.ModuleID = patcher.ModuleID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"ModuleEvents" {
			patchee.ModuleEvents = patcher.ModuleEvents
			continue
		}
		if f == prefix+"ModuleVariables" {
			patchee.ModuleVariables = patcher.ModuleVariables
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationModule executes a gorm list call
func DefaultListNotificationModule(ctx context.Context, db *gorm.DB) ([]*NotificationModule, error) {
	in := NotificationModule{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationModuleORM{}, &NotificationModule{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("module_id")
	ormResponse := []NotificationModuleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationModuleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationModule{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationModuleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationModuleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationModuleORM) error
}

// DefaultCreateModuleEvent executes a basic gorm create call
func DefaultCreateModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ModuleEventORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.EventID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ModuleEventORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ModuleEventORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ModuleEventORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ModuleEventORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.EventID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ModuleEventORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ModuleEventORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleEventSet(ctx context.Context, in []*ModuleEvent, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.EventID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.EventID)
	}
	if hook, ok := (interface{}(&ModuleEventORM{})).(ModuleEventORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("event_id in (?)", keys).Delete(&ModuleEventORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ModuleEventORM{})).(ModuleEventORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ModuleEventORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ModuleEvent, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ModuleEvent, *gorm.DB) error
}

// DefaultStrictUpdateModuleEvent clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateModuleEvent(ctx context.Context, in *ModuleEvent, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateModuleEvent")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ModuleEventORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("event_id=?", ormObj.EventID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEventVariables := EventVariableORM{}
	if ormObj.EventID == 0 {
		return nil, errors.EmptyIdError
	}
	filterEventVariables.ModuleEventEventID = new(uint64)
	*filterEventVariables.ModuleEventEventID = ormObj.EventID
	if err = db.Where(filterEventVariables).Delete(EventVariableORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ModuleEventORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchModuleEvent executes a basic gorm update call with patch behavior
func DefaultPatchModuleEvent(ctx context.Context, in *ModuleEvent, updateMask *field_mask.FieldMask, db *gorm.DB) (*ModuleEvent, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ModuleEvent
	var err error
	if hook, ok := interface{}(&pbObj).(ModuleEventWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(ModuleEventWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskModuleEvent(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ModuleEventWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateModuleEvent(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ModuleEventWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ModuleEventWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ModuleEvent, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetModuleEvent executes a bulk gorm update call with patch behavior
func DefaultPatchSetModuleEvent(ctx context.Context, objects []*ModuleEvent, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ModuleEvent, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ModuleEvent, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchModuleEvent(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskModuleEvent patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskModuleEvent(ctx context.Context, patchee *ModuleEvent, patcher *ModuleEvent, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ModuleEvent, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModule bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"EventID" {
			patchee.EventID = patcher.EventID
			continue
		}
		if !updatedModule && strings.HasPrefix(f, prefix+"Module.") {
			updatedModule = true
			if patcher.Module == nil {
				patchee.Module = nil
				continue
			}
			if patchee.Module == nil {
				patchee.Module = &NotificationModule{}
			}
			if o, err := DefaultApplyFieldMaskNotificationModule(ctx, patchee.Module, patcher.Module, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Module.", db); err != nil {
				return nil, err
			} else {
				patchee.Module = o
			}
			continue
		}
		if f == prefix+"Module" {
			updatedModule = true
			patchee.Module = patcher.Module
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"EventVariables" {
			patchee.EventVariables = patcher.EventVariables
			continue
		}
		if f == prefix+"Notify" {
			patchee.Notify = patcher.Notify
			continue
		}
		if f == prefix+"TemplateTitle" {
			patchee.TemplateTitle = patcher.TemplateTitle
			continue
		}
		if f == prefix+"TemplateDescription" {
			patchee.TemplateDescription = patcher.TemplateDescription
			continue
		}
		if f == prefix+"NotificationModuleModuleId" {
			patchee.NotificationModuleModuleId = patcher.NotificationModuleModuleId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListModuleEvent executes a gorm list call
func DefaultListModuleEvent(ctx context.Context, db *gorm.DB) ([]*ModuleEvent, error) {
	in := ModuleEvent{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ModuleEventORM{}, &ModuleEvent{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("event_id")
	ormResponse := []ModuleEventORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleEventORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ModuleEvent{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ModuleEventORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleEventORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ModuleEventORM) error
}

// DefaultCreateModuleVariable executes a basic gorm create call
func DefaultCreateModuleVariable(ctx context.Context, in *ModuleVariable, db *gorm.DB) (*ModuleVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ModuleVariableORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadModuleVariable(ctx context.Context, in *ModuleVariable, db *gorm.DB) (*ModuleVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.VariableID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ModuleVariableORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ModuleVariableORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ModuleVariableORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ModuleVariableORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleVariable(ctx context.Context, in *ModuleVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.VariableID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ModuleVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ModuleVariableORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleVariableSet(ctx context.Context, in []*ModuleVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.VariableID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.VariableID)
	}
	if hook, ok := (interface{}(&ModuleVariableORM{})).(ModuleVariableORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("variable_id in (?)", keys).Delete(&ModuleVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ModuleVariableORM{})).(ModuleVariableORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ModuleVariableORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ModuleVariable, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ModuleVariable, *gorm.DB) error
}

// DefaultStrictUpdateModuleVariable clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateModuleVariable(ctx context.Context, in *ModuleVariable, db *gorm.DB) (*ModuleVariable, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateModuleVariable")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ModuleVariableORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("variable_id=?", ormObj.VariableID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ModuleVariableORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchModuleVariable executes a basic gorm update call with patch behavior
func DefaultPatchModuleVariable(ctx context.Context, in *ModuleVariable, updateMask *field_mask.FieldMask, db *gorm.DB) (*ModuleVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ModuleVariable
	var err error
	if hook, ok := interface{}(&pbObj).(ModuleVariableWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(ModuleVariableWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskModuleVariable(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ModuleVariableWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateModuleVariable(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ModuleVariableWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ModuleVariableWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ModuleVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ModuleVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ModuleVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ModuleVariable, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetModuleVariable executes a bulk gorm update call with patch behavior
func DefaultPatchSetModuleVariable(ctx context.Context, objects []*ModuleVariable, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ModuleVariable, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ModuleVariable, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchModuleVariable(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskModuleVariable patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskModuleVariable(ctx context.Context, patchee *ModuleVariable, patcher *ModuleVariable, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ModuleVariable, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModule bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"VariableID" {
			patchee.VariableID = patcher.VariableID
			continue
		}
		if !updatedModule && strings.HasPrefix(f, prefix+"Module.") {
			updatedModule = true
			if patcher.Module == nil {
				patchee.Module = nil
				continue
			}
			if patchee.Module == nil {
				patchee.Module = &NotificationModule{}
			}
			if o, err := DefaultApplyFieldMaskNotificationModule(ctx, patchee.Module, patcher.Module, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Module.", db); err != nil {
				return nil, err
			} else {
				patchee.Module = o
			}
			continue
		}
		if f == prefix+"Module" {
			updatedModule = true
			patchee.Module = patcher.Module
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListModuleVariable executes a gorm list call
func DefaultListModuleVariable(ctx context.Context, db *gorm.DB) ([]*ModuleVariable, error) {
	in := ModuleVariable{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ModuleVariableORM{}, &ModuleVariable{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("variable_id")
	ormResponse := []ModuleVariableORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleVariableORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ModuleVariable{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ModuleVariableORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleVariableORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ModuleVariableORM) error
}

// DefaultCreateEventVariable executes a basic gorm create call
func DefaultCreateEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EventVariableORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.VariableID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EventVariableORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EventVariableORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EventVariableORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EventVariableORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.VariableID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EventVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EventVariableORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEventVariableSet(ctx context.Context, in []*EventVariable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.VariableID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.VariableID)
	}
	if hook, ok := (interface{}(&EventVariableORM{})).(EventVariableORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("variable_id in (?)", keys).Delete(&EventVariableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EventVariableORM{})).(EventVariableORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EventVariableORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EventVariable, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EventVariable, *gorm.DB) error
}

// DefaultStrictUpdateEventVariable clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEventVariable(ctx context.Context, in *EventVariable, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEventVariable")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EventVariableORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("variable_id=?", ormObj.VariableID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EventVariableORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEventVariable executes a basic gorm update call with patch behavior
func DefaultPatchEventVariable(ctx context.Context, in *EventVariable, updateMask *field_mask.FieldMask, db *gorm.DB) (*EventVariable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EventVariable
	var err error
	if hook, ok := interface{}(&pbObj).(EventVariableWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(EventVariableWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEventVariable(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EventVariableWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEventVariable(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EventVariableWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EventVariableWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EventVariableWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EventVariableWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EventVariableWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EventVariable, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEventVariable executes a bulk gorm update call with patch behavior
func DefaultPatchSetEventVariable(ctx context.Context, objects []*EventVariable, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EventVariable, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EventVariable, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEventVariable(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEventVariable patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEventVariable(ctx context.Context, patchee *EventVariable, patcher *EventVariable, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EventVariable, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedEvent bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"VariableID" {
			patchee.VariableID = patcher.VariableID
			continue
		}
		if !updatedEvent && strings.HasPrefix(f, prefix+"Event.") {
			updatedEvent = true
			if patcher.Event == nil {
				patchee.Event = nil
				continue
			}
			if patchee.Event == nil {
				patchee.Event = &ModuleEvent{}
			}
			if o, err := DefaultApplyFieldMaskModuleEvent(ctx, patchee.Event, patcher.Event, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Event.", db); err != nil {
				return nil, err
			} else {
				patchee.Event = o
			}
			continue
		}
		if f == prefix+"Event" {
			updatedEvent = true
			patchee.Event = patcher.Event
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Table" {
			patchee.Table = patcher.Table
			continue
		}
		if f == prefix+"ColumnName" {
			patchee.ColumnName = patcher.ColumnName
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEventVariable executes a gorm list call
func DefaultListEventVariable(ctx context.Context, db *gorm.DB) ([]*EventVariable, error) {
	in := EventVariable{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EventVariableORM{}, &EventVariable{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("variable_id")
	ormResponse := []EventVariableORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EventVariableORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EventVariable{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EventVariableORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EventVariableORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EventVariableORM) error
}

// DefaultCreateNotification executes a basic gorm create call
func DefaultCreateNotification(ctx context.Context, in *Notification, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotification(ctx context.Context, in *Notification, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotification(ctx context.Context, in *Notification, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.NotificationID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSet(ctx context.Context, in []*Notification, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.NotificationID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.NotificationID)
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("notification_id in (?)", keys).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Notification, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Notification, *gorm.DB) error
}

// DefaultStrictUpdateNotification clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotification(ctx context.Context, in *Notification, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("notification_id=?", ormObj.NotificationID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotificationEmail := NotificationEmailORM{}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationEmail.NotificationNotificationID = new(uint64)
	*filterNotificationEmail.NotificationNotificationID = ormObj.NotificationID
	if err = db.Where(filterNotificationEmail).Delete(NotificationEmailORM{}).Error; err != nil {
		return nil, err
	}
	filterNotificationSms := NotificationSMSORM{}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationSms.NotificationNotificationID = new(uint64)
	*filterNotificationSms.NotificationNotificationID = ormObj.NotificationID
	if err = db.Where(filterNotificationSms).Delete(NotificationSMSORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotification executes a basic gorm update call with patch behavior
func DefaultPatchNotification(ctx context.Context, in *Notification, updateMask *field_mask.FieldMask, db *gorm.DB) (*Notification, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Notification
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Notification, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotification(ctx context.Context, objects []*Notification, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Notification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Notification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotification(ctx context.Context, patchee *Notification, patcher *Notification, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Notification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedEvent bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	var updatedNotificationSms bool
	var updatedNotificationEmail bool
	var updatedStartAt bool
	var updatedEndAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"NotificationID" {
			patchee.NotificationID = patcher.NotificationID
			continue
		}
		if !updatedEvent && strings.HasPrefix(f, prefix+"Event.") {
			updatedEvent = true
			if patcher.Event == nil {
				patchee.Event = nil
				continue
			}
			if patchee.Event == nil {
				patchee.Event = &ModuleEvent{}
			}
			if o, err := DefaultApplyFieldMaskModuleEvent(ctx, patchee.Event, patcher.Event, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Event.", db); err != nil {
				return nil, err
			} else {
				patchee.Event = o
			}
			continue
		}
		if f == prefix+"Event" {
			updatedEvent = true
			patchee.Event = patcher.Event
			continue
		}
		if f == prefix+"EventID" {
			patchee.EventID = patcher.EventID
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if !updatedNotificationSms && strings.HasPrefix(f, prefix+"NotificationSms.") {
			updatedNotificationSms = true
			if patcher.NotificationSms == nil {
				patchee.NotificationSms = nil
				continue
			}
			if patchee.NotificationSms == nil {
				patchee.NotificationSms = &NotificationSMS{}
			}
			if o, err := DefaultApplyFieldMaskNotificationSMS(ctx, patchee.NotificationSms, patcher.NotificationSms, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationSms.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationSms = o
			}
			continue
		}
		if f == prefix+"NotificationSms" {
			updatedNotificationSms = true
			patchee.NotificationSms = patcher.NotificationSms
			continue
		}
		if !updatedNotificationEmail && strings.HasPrefix(f, prefix+"NotificationEmail.") {
			updatedNotificationEmail = true
			if patcher.NotificationEmail == nil {
				patchee.NotificationEmail = nil
				continue
			}
			if patchee.NotificationEmail == nil {
				patchee.NotificationEmail = &NotificationEmail{}
			}
			if o, err := DefaultApplyFieldMaskNotificationEmail(ctx, patchee.NotificationEmail, patcher.NotificationEmail, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationEmail.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationEmail = o
			}
			continue
		}
		if f == prefix+"NotificationEmail" {
			updatedNotificationEmail = true
			patchee.NotificationEmail = patcher.NotificationEmail
			continue
		}
		if !updatedStartAt && strings.HasPrefix(f, prefix+"StartAt.") {
			if patcher.StartAt == nil {
				patchee.StartAt = nil
				continue
			}
			if patchee.StartAt == nil {
				patchee.StartAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartAt, patchee.StartAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartAt" {
			updatedStartAt = true
			patchee.StartAt = patcher.StartAt
			continue
		}
		if !updatedEndAt && strings.HasPrefix(f, prefix+"EndAt.") {
			if patcher.EndAt == nil {
				patchee.EndAt = nil
				continue
			}
			if patchee.EndAt == nil {
				patchee.EndAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndAt, patchee.EndAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndAt" {
			updatedEndAt = true
			patchee.EndAt = patcher.EndAt
			continue
		}
		if f == prefix+"AllCompany" {
			patchee.AllCompany = patcher.AllCompany
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"ModuleName" {
			patchee.ModuleName = patcher.ModuleName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotification executes a gorm list call
func DefaultListNotification(ctx context.Context, db *gorm.DB) ([]*Notification, error) {
	in := Notification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationORM{}, &Notification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("notification_id")
	ormResponse := []NotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Notification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationORM) error
}

// DefaultCreateNotificationFCM executes a basic gorm create call
func DefaultCreateNotificationFCM(ctx context.Context, in *NotificationFCM, db *gorm.DB) (*NotificationFCM, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationFCMORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationFCM(ctx context.Context, in *NotificationFCM, db *gorm.DB) (*NotificationFCM, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.NotificationID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationFCMORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationFCMORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationFCMORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationFCMORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationFCM(ctx context.Context, in *NotificationFCM, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.NotificationID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationFCMORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationFCMORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationFCMSet(ctx context.Context, in []*NotificationFCM, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.NotificationID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.NotificationID)
	}
	if hook, ok := (interface{}(&NotificationFCMORM{})).(NotificationFCMORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("notification_id in (?)", keys).Delete(&NotificationFCMORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationFCMORM{})).(NotificationFCMORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationFCMORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationFCM, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationFCM, *gorm.DB) error
}

// DefaultStrictUpdateNotificationFCM clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationFCM(ctx context.Context, in *NotificationFCM, db *gorm.DB) (*NotificationFCM, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationFCM")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationFCMORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("notification_id=?", ormObj.NotificationID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationFCMORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationFCM executes a basic gorm update call with patch behavior
func DefaultPatchNotificationFCM(ctx context.Context, in *NotificationFCM, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationFCM, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationFCM
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationFCMWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationFCMWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationFCM(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationFCMWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationFCM(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationFCMWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationFCMWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationFCM, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationFCM, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationFCM, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationFCM, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationFCM executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationFCM(ctx context.Context, objects []*NotificationFCM, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationFCM, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationFCM, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationFCM(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationFCM patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationFCM(ctx context.Context, patchee *NotificationFCM, patcher *NotificationFCM, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationFCM, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"NotificationID" {
			patchee.NotificationID = patcher.NotificationID
			continue
		}
		if f == prefix+"UserID" {
			patchee.UserID = patcher.UserID
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ModuleID" {
			patchee.ModuleID = patcher.ModuleID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"ModuleName" {
			patchee.ModuleName = patcher.ModuleName
			continue
		}
		if f == prefix+"Times" {
			patchee.Times = patcher.Times
			continue
		}
		if f == prefix+"IsRead" {
			patchee.IsRead = patcher.IsRead
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationFCM executes a gorm list call
func DefaultListNotificationFCM(ctx context.Context, db *gorm.DB) ([]*NotificationFCM, error) {
	in := NotificationFCM{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationFCMORM{}, &NotificationFCM{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("notification_id")
	ormResponse := []NotificationFCMORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationFCMORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationFCM{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationFCMORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationFCMORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationFCMORM) error
}

// DefaultCreateNotificationCompany executes a basic gorm create call
func DefaultCreateNotificationCompany(ctx context.Context, in *NotificationCompany, db *gorm.DB) (*NotificationCompany, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationCompanyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationCompany(ctx context.Context, in *NotificationCompany, db *gorm.DB) (*NotificationCompany, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.NotificationCompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationCompanyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationCompanyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationCompanyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationCompanyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationCompany(ctx context.Context, in *NotificationCompany, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.NotificationCompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationCompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationCompanyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationCompanySet(ctx context.Context, in []*NotificationCompany, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.NotificationCompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.NotificationCompanyID)
	}
	if hook, ok := (interface{}(&NotificationCompanyORM{})).(NotificationCompanyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("notification_company_id in (?)", keys).Delete(&NotificationCompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationCompanyORM{})).(NotificationCompanyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationCompanyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationCompany, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationCompany, *gorm.DB) error
}

// DefaultStrictUpdateNotificationCompany clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationCompany(ctx context.Context, in *NotificationCompany, db *gorm.DB) (*NotificationCompany, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationCompany")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationCompanyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("notification_company_id=?", ormObj.NotificationCompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationCompanyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationCompany executes a basic gorm update call with patch behavior
func DefaultPatchNotificationCompany(ctx context.Context, in *NotificationCompany, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationCompany, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationCompany
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationCompanyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationCompanyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationCompany(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationCompanyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationCompany(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationCompanyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationCompanyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationCompany, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationCompany, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationCompany, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationCompany, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationCompany executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationCompany(ctx context.Context, objects []*NotificationCompany, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationCompany, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationCompany, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationCompany(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationCompany patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationCompany(ctx context.Context, patchee *NotificationCompany, patcher *NotificationCompany, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationCompany, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotification bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"NotificationCompanyID" {
			patchee.NotificationCompanyID = patcher.NotificationCompanyID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedNotification && strings.HasPrefix(f, prefix+"Notification.") {
			updatedNotification = true
			if patcher.Notification == nil {
				patchee.Notification = nil
				continue
			}
			if patchee.Notification == nil {
				patchee.Notification = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notification, patcher.Notification, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notification.", db); err != nil {
				return nil, err
			} else {
				patchee.Notification = o
			}
			continue
		}
		if f == prefix+"Notification" {
			updatedNotification = true
			patchee.Notification = patcher.Notification
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationCompany executes a gorm list call
func DefaultListNotificationCompany(ctx context.Context, db *gorm.DB) ([]*NotificationCompany, error) {
	in := NotificationCompany{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationCompanyORM{}, &NotificationCompany{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("notification_company_id")
	ormResponse := []NotificationCompanyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationCompanyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationCompany{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationCompanyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationCompanyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationCompanyORM) error
}

// DefaultCreateNotificationTask executes a basic gorm create call
func DefaultCreateNotificationTask(ctx context.Context, in *NotificationTask, db *gorm.DB) (*NotificationTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationTaskORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationTask(ctx context.Context, in *NotificationTask, db *gorm.DB) (*NotificationTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.TaskID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationTaskORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationTaskORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationTaskORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationTaskORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationTask(ctx context.Context, in *NotificationTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.TaskID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationTaskORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationTaskSet(ctx context.Context, in []*NotificationTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.TaskID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.TaskID)
	}
	if hook, ok := (interface{}(&NotificationTaskORM{})).(NotificationTaskORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("task_id in (?)", keys).Delete(&NotificationTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationTaskORM{})).(NotificationTaskORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationTaskORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationTask, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationTask, *gorm.DB) error
}

// DefaultStrictUpdateNotificationTask clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationTask(ctx context.Context, in *NotificationTask, db *gorm.DB) (*NotificationTask, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationTask")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationTaskORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("TaskID=?", ormObj.TaskID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotification := NotificationORM{}
	if ormObj.TaskID == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotification.NotificationTaskTaskID = new(uint64)
	*filterNotification.NotificationTaskTaskID = ormObj.TaskID
	if err = db.Where(filterNotification).Delete(NotificationORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationTaskORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationTask executes a basic gorm update call with patch behavior
func DefaultPatchNotificationTask(ctx context.Context, in *NotificationTask, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationTask
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationTaskWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationTaskWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationTask(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationTaskWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationTask(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationTaskWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationTaskWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationTask, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationTask executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationTask(ctx context.Context, objects []*NotificationTask, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationTask, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationTask, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationTask(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationTask patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationTask(ctx context.Context, patchee *NotificationTask, patcher *NotificationTask, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationTask, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotification bool
	for i, f := range updateMask.Paths {
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"NotificationID" {
			patchee.NotificationID = patcher.NotificationID
			continue
		}
		if !updatedNotification && strings.HasPrefix(f, prefix+"Notification.") {
			updatedNotification = true
			if patcher.Notification == nil {
				patchee.Notification = nil
				continue
			}
			if patchee.Notification == nil {
				patchee.Notification = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notification, patcher.Notification, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notification.", db); err != nil {
				return nil, err
			} else {
				patchee.Notification = o
			}
			continue
		}
		if f == prefix+"Notification" {
			updatedNotification = true
			patchee.Notification = patcher.Notification
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationTask executes a gorm list call
func DefaultListNotificationTask(ctx context.Context, db *gorm.DB) ([]*NotificationTask, error) {
	in := NotificationTask{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationTaskORM{}, &NotificationTask{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("TaskID")
	ormResponse := []NotificationTaskORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationTaskORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationTask{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationTaskORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationTaskORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationTaskORM) error
}

// DefaultCreateNotificationSMS executes a basic gorm create call
func DefaultCreateNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSMSORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.SmsDeliveryID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationSMSORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationSMSORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationSMSORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSMSORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.SmsDeliveryID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationSMSORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationSMSORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSMSSet(ctx context.Context, in []*NotificationSMS, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.SmsDeliveryID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.SmsDeliveryID)
	}
	if hook, ok := (interface{}(&NotificationSMSORM{})).(NotificationSMSORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("sms_delivery_id in (?)", keys).Delete(&NotificationSMSORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationSMSORM{})).(NotificationSMSORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationSMSORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationSMS, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationSMS, *gorm.DB) error
}

// DefaultStrictUpdateNotificationSMS clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationSMS(ctx context.Context, in *NotificationSMS, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationSMS")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationSMSORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("sms_delivery_id=?", ormObj.SmsDeliveryID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationSMSORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationSMS executes a basic gorm update call with patch behavior
func DefaultPatchNotificationSMS(ctx context.Context, in *NotificationSMS, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationSMS, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationSMS
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationSMSWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationSMSWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationSMS(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationSMSWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationSMS(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationSMSWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationSMSWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationSMS, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationSMS executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationSMS(ctx context.Context, objects []*NotificationSMS, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationSMS, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationSMS, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationSMS(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationSMS patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationSMS(ctx context.Context, patchee *NotificationSMS, patcher *NotificationSMS, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationSMS, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotification bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"SmsDeliveryID" {
			patchee.SmsDeliveryID = patcher.SmsDeliveryID
			continue
		}
		if !updatedNotification && strings.HasPrefix(f, prefix+"Notification.") {
			updatedNotification = true
			if patcher.Notification == nil {
				patchee.Notification = nil
				continue
			}
			if patchee.Notification == nil {
				patchee.Notification = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notification, patcher.Notification, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notification.", db); err != nil {
				return nil, err
			} else {
				patchee.Notification = o
			}
			continue
		}
		if f == prefix+"Notification" {
			updatedNotification = true
			patchee.Notification = patcher.Notification
			continue
		}
		if f == prefix+"Rekening" {
			patchee.Rekening = patcher.Rekening
			continue
		}
		if f == prefix+"Produk" {
			patchee.Produk = patcher.Produk
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationSMS executes a gorm list call
func DefaultListNotificationSMS(ctx context.Context, db *gorm.DB) ([]*NotificationSMS, error) {
	in := NotificationSMS{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationSMSORM{}, &NotificationSMS{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("sms_delivery_id")
	ormResponse := []NotificationSMSORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSMSORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationSMS{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationSMSORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSMSORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationSMSORM) error
}

// DefaultCreateNotificationEmail executes a basic gorm create call
func DefaultCreateNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationEmailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.EmailDeliveryID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationEmailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationEmailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationEmailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationEmailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.EmailDeliveryID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationEmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationEmailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationEmailSet(ctx context.Context, in []*NotificationEmail, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.EmailDeliveryID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.EmailDeliveryID)
	}
	if hook, ok := (interface{}(&NotificationEmailORM{})).(NotificationEmailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("email_delivery_id in (?)", keys).Delete(&NotificationEmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationEmailORM{})).(NotificationEmailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationEmailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationEmail, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationEmail, *gorm.DB) error
}

// DefaultStrictUpdateNotificationEmail clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationEmail(ctx context.Context, in *NotificationEmail, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationEmailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("email_delivery_id=?", ormObj.EmailDeliveryID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationEmailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationEmail executes a basic gorm update call with patch behavior
func DefaultPatchNotificationEmail(ctx context.Context, in *NotificationEmail, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationEmail, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationEmail
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationEmailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(NotificationEmailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationEmail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationEmailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationEmail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationEmailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationEmailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationEmail, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationEmail executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationEmail(ctx context.Context, objects []*NotificationEmail, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationEmail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationEmail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationEmail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationEmail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationEmail(ctx context.Context, patchee *NotificationEmail, patcher *NotificationEmail, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationEmail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotification bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"EmailDeliveryID" {
			patchee.EmailDeliveryID = patcher.EmailDeliveryID
			continue
		}
		if !updatedNotification && strings.HasPrefix(f, prefix+"Notification.") {
			updatedNotification = true
			if patcher.Notification == nil {
				patchee.Notification = nil
				continue
			}
			if patchee.Notification == nil {
				patchee.Notification = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notification, patcher.Notification, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notification.", db); err != nil {
				return nil, err
			} else {
				patchee.Notification = o
			}
			continue
		}
		if f == prefix+"Notification" {
			updatedNotification = true
			patchee.Notification = patcher.Notification
			continue
		}
		if f == prefix+"Produk" {
			patchee.Produk = patcher.Produk
			continue
		}
		if f == prefix+"EmailTo" {
			patchee.EmailTo = patcher.EmailTo
			continue
		}
		if f == prefix+"EmailCc" {
			patchee.EmailCc = patcher.EmailCc
			continue
		}
		if f == prefix+"Subject" {
			patchee.Subject = patcher.Subject
			continue
		}
		if f == prefix+"Body" {
			patchee.Body = patcher.Body
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationEmail executes a gorm list call
func DefaultListNotificationEmail(ctx context.Context, db *gorm.DB) ([]*NotificationEmail, error) {
	in := NotificationEmail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationEmailORM{}, &NotificationEmail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("email_delivery_id")
	ormResponse := []NotificationEmailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationEmail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationEmailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationEmailORM) error
}

// DefaultCreateTempClient executes a basic gorm create call
func DefaultCreateTempClient(ctx context.Context, in *TempClient, db *gorm.DB) (*TempClient, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TempClientORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTempClient(ctx context.Context, in *TempClient, db *gorm.DB) (*TempClient, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.ClientID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TempClientORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TempClientORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TempClientORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TempClientORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTempClient(ctx context.Context, in *TempClient, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.ClientID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TempClientORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TempClientORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTempClientSet(ctx context.Context, in []*TempClient, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.ClientID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.ClientID)
	}
	if hook, ok := (interface{}(&TempClientORM{})).(TempClientORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("client_id in (?)", keys).Delete(&TempClientORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TempClientORM{})).(TempClientORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TempClientORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TempClient, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TempClient, *gorm.DB) error
}

// DefaultStrictUpdateTempClient clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTempClient(ctx context.Context, in *TempClient, db *gorm.DB) (*TempClient, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTempClient")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TempClientORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("ClientID=?", ormObj.ClientID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TempClientORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTempClient executes a basic gorm update call with patch behavior
func DefaultPatchTempClient(ctx context.Context, in *TempClient, updateMask *field_mask.FieldMask, db *gorm.DB) (*TempClient, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TempClient
	var err error
	if hook, ok := interface{}(&pbObj).(TempClientWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(TempClientWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTempClient(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TempClientWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTempClient(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TempClientWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TempClientWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TempClient, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TempClientWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TempClient, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TempClientWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TempClient, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TempClientWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TempClient, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTempClient executes a bulk gorm update call with patch behavior
func DefaultPatchSetTempClient(ctx context.Context, objects []*TempClient, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TempClient, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TempClient, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTempClient(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTempClient patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTempClient(ctx context.Context, patchee *TempClient, patcher *TempClient, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TempClient, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"ClientID" {
			patchee.ClientID = patcher.ClientID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Phone" {
			patchee.Phone = patcher.Phone
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTempClient executes a gorm list call
func DefaultListTempClient(ctx context.Context, db *gorm.DB) ([]*TempClient, error) {
	in := TempClient{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TempClientORM{}, &TempClient{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("ClientID")
	ormResponse := []TempClientORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TempClientORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TempClient{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TempClientORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TempClientORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TempClientORM) error
}

// DefaultCreateDefaultNotifications executes a basic gorm create call
func DefaultCreateDefaultNotifications(ctx context.Context, in *DefaultNotifications, db *gorm.DB) (*DefaultNotifications, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DefaultNotificationsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDefaultNotifications(ctx context.Context, in *DefaultNotifications, db *gorm.DB) (*DefaultNotifications, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.DefaultID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &DefaultNotificationsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DefaultNotificationsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DefaultNotificationsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DefaultNotificationsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDefaultNotifications(ctx context.Context, in *DefaultNotifications, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.DefaultID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DefaultNotificationsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DefaultNotificationsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDefaultNotificationsSet(ctx context.Context, in []*DefaultNotifications, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.DefaultID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.DefaultID)
	}
	if hook, ok := (interface{}(&DefaultNotificationsORM{})).(DefaultNotificationsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("default_id in (?)", keys).Delete(&DefaultNotificationsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DefaultNotificationsORM{})).(DefaultNotificationsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DefaultNotificationsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DefaultNotifications, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DefaultNotifications, *gorm.DB) error
}

// DefaultStrictUpdateDefaultNotifications clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDefaultNotifications(ctx context.Context, in *DefaultNotifications, db *gorm.DB) (*DefaultNotifications, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDefaultNotifications")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DefaultNotificationsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("default_id=?", ormObj.DefaultID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DefaultNotificationsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDefaultNotifications executes a basic gorm update call with patch behavior
func DefaultPatchDefaultNotifications(ctx context.Context, in *DefaultNotifications, updateMask *field_mask.FieldMask, db *gorm.DB) (*DefaultNotifications, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DefaultNotifications
	var err error
	if hook, ok := interface{}(&pbObj).(DefaultNotificationsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(DefaultNotificationsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDefaultNotifications(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DefaultNotificationsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDefaultNotifications(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DefaultNotificationsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DefaultNotificationsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DefaultNotifications, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DefaultNotifications, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DefaultNotifications, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DefaultNotifications, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDefaultNotifications executes a bulk gorm update call with patch behavior
func DefaultPatchSetDefaultNotifications(ctx context.Context, objects []*DefaultNotifications, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DefaultNotifications, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DefaultNotifications, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDefaultNotifications(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDefaultNotifications patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDefaultNotifications(ctx context.Context, patchee *DefaultNotifications, patcher *DefaultNotifications, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DefaultNotifications, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"DefaultID" {
			patchee.DefaultID = patcher.DefaultID
			continue
		}
		if f == prefix+"EventName" {
			patchee.EventName = patcher.EventName
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Message" {
			patchee.Message = patcher.Message
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDefaultNotifications executes a gorm list call
func DefaultListDefaultNotifications(ctx context.Context, db *gorm.DB) ([]*DefaultNotifications, error) {
	in := DefaultNotifications{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DefaultNotificationsORM{}, &DefaultNotifications{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("default_id")
	ormResponse := []DefaultNotificationsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DefaultNotificationsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DefaultNotifications{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DefaultNotificationsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DefaultNotificationsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DefaultNotificationsORM) error
}

// DefaultCreateNotificationEmailTemplate executes a basic gorm create call
func DefaultCreateNotificationEmailTemplate(ctx context.Context, in *NotificationEmailTemplate, db *gorm.DB) (*NotificationEmailTemplate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationEmailTemplateORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationEmailTemplate(ctx context.Context, in *NotificationEmailTemplate, db *gorm.DB) (*NotificationEmailTemplate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationEmailTemplateORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationEmailTemplateORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationEmailTemplateORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationEmailTemplateORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationEmailTemplate(ctx context.Context, in *NotificationEmailTemplate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationEmailTemplateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationEmailTemplateORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationEmailTemplateSet(ctx context.Context, in []*NotificationEmailTemplate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationEmailTemplateORM{})).(NotificationEmailTemplateORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NotificationEmailTemplateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationEmailTemplateORM{})).(NotificationEmailTemplateORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationEmailTemplateORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationEmailTemplate, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationEmailTemplate, *gorm.DB) error
}

// DefaultStrictUpdateNotificationEmailTemplate clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationEmailTemplate(ctx context.Context, in *NotificationEmailTemplate, db *gorm.DB) (*NotificationEmailTemplate, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationEmailTemplate")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationEmailTemplateORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationEmailTemplateORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationEmailTemplate executes a basic gorm update call with patch behavior
func DefaultPatchNotificationEmailTemplate(ctx context.Context, in *NotificationEmailTemplate, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationEmailTemplate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationEmailTemplate
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationEmailTemplateWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotificationEmailTemplate(ctx, &NotificationEmailTemplate{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationEmailTemplateWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationEmailTemplate(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationEmailTemplateWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationEmailTemplate(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationEmailTemplateWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationEmailTemplateWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationEmailTemplate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationEmailTemplate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationEmailTemplate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationEmailTemplate, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationEmailTemplate executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationEmailTemplate(ctx context.Context, objects []*NotificationEmailTemplate, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationEmailTemplate, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationEmailTemplate, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationEmailTemplate(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationEmailTemplate patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationEmailTemplate(ctx context.Context, patchee *NotificationEmailTemplate, patcher *NotificationEmailTemplate, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationEmailTemplate, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationEmailTemplate executes a gorm list call
func DefaultListNotificationEmailTemplate(ctx context.Context, db *gorm.DB) ([]*NotificationEmailTemplate, error) {
	in := NotificationEmailTemplate{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationEmailTemplateORM{}, &NotificationEmailTemplate{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationEmailTemplateORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationEmailTemplateORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationEmailTemplate{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationEmailTemplateORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationEmailTemplateORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationEmailTemplateORM) error
}
