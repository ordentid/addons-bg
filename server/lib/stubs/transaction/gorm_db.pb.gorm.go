package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type CurrencyORM struct {
	CreatedAt *time.Time `gorm:"not null"`
	Id        uint64     `gorm:"primary_key;not null"`
	Name      string
	UpdatedAt *time.Time `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (CurrencyORM) TableName() string {
	return "currency"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Currency) ToORM(ctx context.Context) (CurrencyORM, error) {
	to := CurrencyORM{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(CurrencyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CurrencyORM) ToPB(ctx context.Context) (Currency, error) {
	to := Currency{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(CurrencyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Currency the arg will be the target, the caller the one being converted from

// CurrencyBeforeToORM called before default ToORM code
type CurrencyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CurrencyORM) error
}

// CurrencyAfterToORM called after default ToORM code
type CurrencyWithAfterToORM interface {
	AfterToORM(context.Context, *CurrencyORM) error
}

// CurrencyBeforeToPB called before default ToPB code
type CurrencyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Currency) error
}

// CurrencyAfterToPB called after default ToPB code
type CurrencyWithAfterToPB interface {
	AfterToPB(context.Context, *Currency) error
}

type TransactionORM struct {
	CompanyId      uint64
	CreatedAt      *time.Time
	CreditAccount  string
	CreditAmount   string
	CreditCurrency string
	DebitAccount   string
	DebitAmount    string
	DebitCurrency  string
	DeletedAt      *time.Time
	ExternalId     string `gorm:"type:text"`
	Feature        string `gorm:"type:varchar(255)"`
	FeatureId      uint64
	HoldingId      uint64
	IsRetry        bool
	IsSchedule     bool
	JurnalSeq      string `gorm:"type:text"`
	ModuleId       uint64
	ResponseDetail string `gorm:"type:text"`
	RetryNumber    uint32
	ScheduleDate   *time.Time
	Status         string `gorm:"type:varchar(5);default:1"`
	TransactionId  uint64 `gorm:"primary_key;not null"`
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (TransactionORM) TableName() string {
	return "transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Transaction) ToORM(ctx context.Context) (TransactionORM, error) {
	to := TransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TransactionId = m.TransactionId
	to.Status = m.Status
	to.IsSchedule = m.IsSchedule
	if m.ScheduleDate != nil {
		t := m.ScheduleDate.AsTime()
		to.ScheduleDate = &t
	}
	to.ModuleId = m.ModuleId
	to.Feature = m.Feature
	to.FeatureId = m.FeatureId
	to.ExternalId = m.ExternalId
	to.JurnalSeq = m.JurnalSeq
	to.ResponseDetail = m.ResponseDetail
	to.IsRetry = m.IsRetry
	to.RetryNumber = m.RetryNumber
	to.DebitAmount = m.DebitAmount
	to.CreditAmount = m.CreditAmount
	to.DebitCurrency = m.DebitCurrency
	to.CreditCurrency = m.CreditCurrency
	to.DebitAccount = m.DebitAccount
	to.CreditAccount = m.CreditAccount
	to.CompanyId = m.CompanyId
	to.HoldingId = m.HoldingId
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(TransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionORM) ToPB(ctx context.Context) (Transaction, error) {
	to := Transaction{}
	var err error
	if prehook, ok := interface{}(m).(TransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TransactionId = m.TransactionId
	to.Status = m.Status
	to.IsSchedule = m.IsSchedule
	if m.ScheduleDate != nil {
		to.ScheduleDate = timestamppb.New(*m.ScheduleDate)
	}
	to.ModuleId = m.ModuleId
	to.Feature = m.Feature
	to.FeatureId = m.FeatureId
	to.ExternalId = m.ExternalId
	to.JurnalSeq = m.JurnalSeq
	to.ResponseDetail = m.ResponseDetail
	to.IsRetry = m.IsRetry
	to.RetryNumber = m.RetryNumber
	to.DebitAmount = m.DebitAmount
	to.CreditAmount = m.CreditAmount
	to.DebitCurrency = m.DebitCurrency
	to.CreditCurrency = m.CreditCurrency
	to.DebitAccount = m.DebitAccount
	to.CreditAccount = m.CreditAccount
	to.CompanyId = m.CompanyId
	to.HoldingId = m.HoldingId
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(TransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Transaction the arg will be the target, the caller the one being converted from

// TransactionBeforeToORM called before default ToORM code
type TransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionORM) error
}

// TransactionAfterToORM called after default ToORM code
type TransactionWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionORM) error
}

// TransactionBeforeToPB called before default ToPB code
type TransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Transaction) error
}

// TransactionAfterToPB called after default ToPB code
type TransactionWithAfterToPB interface {
	AfterToPB(context.Context, *Transaction) error
}

type SchedulerORM struct {
	CreatedAt     *time.Time
	IsCutOff      bool            `gorm:"default:false"`
	ScheduleDate  *time.Time      `gorm:"default:NULL"`
	SchedulerId   uint64          `gorm:"primary_key;not null"`
	Status        uint32          `gorm:"default:0"`
	Transaction   *TransactionORM `gorm:"foreignkey:TransactionId;association_foreignkey:TransactionId"`
	TransactionId *uint64
}

// TableName overrides the default tablename generated by GORM
func (SchedulerORM) TableName() string {
	return "schedulers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Scheduler) ToORM(ctx context.Context) (SchedulerORM, error) {
	to := SchedulerORM{}
	var err error
	if prehook, ok := interface{}(m).(SchedulerWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SchedulerId = m.SchedulerId
	if m.Transaction != nil {
		tempTransaction, err := m.Transaction.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Transaction = &tempTransaction
	}
	to.Status = m.Status
	if m.ScheduleDate != nil {
		t := m.ScheduleDate.AsTime()
		to.ScheduleDate = &t
	}
	to.IsCutOff = m.IsCutOff
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(SchedulerWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SchedulerORM) ToPB(ctx context.Context) (Scheduler, error) {
	to := Scheduler{}
	var err error
	if prehook, ok := interface{}(m).(SchedulerWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SchedulerId = m.SchedulerId
	if m.Transaction != nil {
		tempTransaction, err := m.Transaction.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Transaction = &tempTransaction
	}
	to.Status = m.Status
	if m.ScheduleDate != nil {
		to.ScheduleDate = timestamppb.New(*m.ScheduleDate)
	}
	to.IsCutOff = m.IsCutOff
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(SchedulerWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Scheduler the arg will be the target, the caller the one being converted from

// SchedulerBeforeToORM called before default ToORM code
type SchedulerWithBeforeToORM interface {
	BeforeToORM(context.Context, *SchedulerORM) error
}

// SchedulerAfterToORM called after default ToORM code
type SchedulerWithAfterToORM interface {
	AfterToORM(context.Context, *SchedulerORM) error
}

// SchedulerBeforeToPB called before default ToPB code
type SchedulerWithBeforeToPB interface {
	BeforeToPB(context.Context, *Scheduler) error
}

// SchedulerAfterToPB called after default ToPB code
type SchedulerWithAfterToPB interface {
	AfterToPB(context.Context, *Scheduler) error
}

type HostToHostConfigORM struct {
	ConfigId             uint64 `gorm:"primary_key;not null"`
	DirectoryPassword    string `gorm:"not null"`
	DirectoryUrl         string `gorm:"not null"`
	DirectoryUsername    string `gorm:"not null"`
	Encryption           string
	EncryptionPrivateKey string `gorm:"type:text;not null"`
	EncryptionPublicKey  string `gorm:"type:text;not null"`
	HostToHostUserId     uint64 `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (HostToHostConfigORM) TableName() string {
	return "host_to_host_configs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HostToHostConfig) ToORM(ctx context.Context) (HostToHostConfigORM, error) {
	to := HostToHostConfigORM{}
	var err error
	if prehook, ok := interface{}(m).(HostToHostConfigWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ConfigId = m.ConfigId
	to.DirectoryUrl = m.DirectoryUrl
	to.DirectoryUsername = m.DirectoryUsername
	to.DirectoryPassword = m.DirectoryPassword
	to.HostToHostUserId = m.HostToHostUserId
	to.Encryption = m.Encryption
	to.EncryptionPrivateKey = m.EncryptionPrivateKey
	to.EncryptionPublicKey = m.EncryptionPublicKey
	if posthook, ok := interface{}(m).(HostToHostConfigWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HostToHostConfigORM) ToPB(ctx context.Context) (HostToHostConfig, error) {
	to := HostToHostConfig{}
	var err error
	if prehook, ok := interface{}(m).(HostToHostConfigWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ConfigId = m.ConfigId
	to.DirectoryUrl = m.DirectoryUrl
	to.DirectoryUsername = m.DirectoryUsername
	to.DirectoryPassword = m.DirectoryPassword
	to.HostToHostUserId = m.HostToHostUserId
	to.Encryption = m.Encryption
	to.EncryptionPrivateKey = m.EncryptionPrivateKey
	to.EncryptionPublicKey = m.EncryptionPublicKey
	if posthook, ok := interface{}(m).(HostToHostConfigWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HostToHostConfig the arg will be the target, the caller the one being converted from

// HostToHostConfigBeforeToORM called before default ToORM code
type HostToHostConfigWithBeforeToORM interface {
	BeforeToORM(context.Context, *HostToHostConfigORM) error
}

// HostToHostConfigAfterToORM called after default ToORM code
type HostToHostConfigWithAfterToORM interface {
	AfterToORM(context.Context, *HostToHostConfigORM) error
}

// HostToHostConfigBeforeToPB called before default ToPB code
type HostToHostConfigWithBeforeToPB interface {
	BeforeToPB(context.Context, *HostToHostConfig) error
}

// HostToHostConfigAfterToPB called after default ToPB code
type HostToHostConfigWithAfterToPB interface {
	AfterToPB(context.Context, *HostToHostConfig) error
}

// DefaultCreateCurrency executes a basic gorm create call
func DefaultCreateCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CurrencyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CurrencyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CurrencyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCurrency(ctx context.Context, in *Currency, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CurrencyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCurrencySet(ctx context.Context, in []*Currency, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CurrencyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Currency, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Currency, *gorm.DB) error
}

// DefaultStrictUpdateCurrency clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCurrency")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CurrencyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CurrencyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCurrency executes a basic gorm update call with patch behavior
func DefaultPatchCurrency(ctx context.Context, in *Currency, updateMask *field_mask.FieldMask, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Currency
	var err error
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCurrency(ctx, &Currency{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCurrency(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCurrency(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CurrencyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CurrencyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCurrency executes a bulk gorm update call with patch behavior
func DefaultPatchSetCurrency(ctx context.Context, objects []*Currency, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Currency, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Currency, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCurrency(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCurrency patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCurrency(ctx context.Context, patchee *Currency, patcher *Currency, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Currency, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCurrency executes a gorm list call
func DefaultListCurrency(ctx context.Context, db *gorm.DB) ([]*Currency, error) {
	in := Currency{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CurrencyORM{}, &Currency{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CurrencyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Currency{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CurrencyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CurrencyORM) error
}

// DefaultCreateTransaction executes a basic gorm create call
func DefaultCreateTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.TransactionId == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransaction(ctx context.Context, in *Transaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.TransactionId == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSet(ctx context.Context, in []*Transaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.TransactionId == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.TransactionId)
	}
	if hook, ok := (interface{}(&TransactionORM{})).(TransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("transaction_id in (?)", keys).Delete(&TransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionORM{})).(TransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Transaction, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Transaction, *gorm.DB) error
}

// DefaultStrictUpdateTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("transaction_id=?", ormObj.TransactionId).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransaction executes a basic gorm update call with patch behavior
func DefaultPatchTransaction(ctx context.Context, in *Transaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Transaction
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransaction(ctx context.Context, objects []*Transaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Transaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Transaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransaction(ctx context.Context, patchee *Transaction, patcher *Transaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Transaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedScheduleDate bool
	var updatedDeletedAt bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"TransactionId" {
			patchee.TransactionId = patcher.TransactionId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"IsSchedule" {
			patchee.IsSchedule = patcher.IsSchedule
			continue
		}
		if !updatedScheduleDate && strings.HasPrefix(f, prefix+"ScheduleDate.") {
			if patcher.ScheduleDate == nil {
				patchee.ScheduleDate = nil
				continue
			}
			if patchee.ScheduleDate == nil {
				patchee.ScheduleDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ScheduleDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ScheduleDate, patchee.ScheduleDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ScheduleDate" {
			updatedScheduleDate = true
			patchee.ScheduleDate = patcher.ScheduleDate
			continue
		}
		if f == prefix+"ModuleId" {
			patchee.ModuleId = patcher.ModuleId
			continue
		}
		if f == prefix+"Feature" {
			patchee.Feature = patcher.Feature
			continue
		}
		if f == prefix+"FeatureId" {
			patchee.FeatureId = patcher.FeatureId
			continue
		}
		if f == prefix+"ExternalId" {
			patchee.ExternalId = patcher.ExternalId
			continue
		}
		if f == prefix+"JurnalSeq" {
			patchee.JurnalSeq = patcher.JurnalSeq
			continue
		}
		if f == prefix+"ResponseDetail" {
			patchee.ResponseDetail = patcher.ResponseDetail
			continue
		}
		if f == prefix+"IsRetry" {
			patchee.IsRetry = patcher.IsRetry
			continue
		}
		if f == prefix+"RetryNumber" {
			patchee.RetryNumber = patcher.RetryNumber
			continue
		}
		if f == prefix+"DebitAmount" {
			patchee.DebitAmount = patcher.DebitAmount
			continue
		}
		if f == prefix+"CreditAmount" {
			patchee.CreditAmount = patcher.CreditAmount
			continue
		}
		if f == prefix+"DebitCurrency" {
			patchee.DebitCurrency = patcher.DebitCurrency
			continue
		}
		if f == prefix+"CreditCurrency" {
			patchee.CreditCurrency = patcher.CreditCurrency
			continue
		}
		if f == prefix+"DebitAccount" {
			patchee.DebitAccount = patcher.DebitAccount
			continue
		}
		if f == prefix+"CreditAccount" {
			patchee.CreditAccount = patcher.CreditAccount
			continue
		}
		if f == prefix+"CompanyId" {
			patchee.CompanyId = patcher.CompanyId
			continue
		}
		if f == prefix+"HoldingId" {
			patchee.HoldingId = patcher.HoldingId
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransaction executes a gorm list call
func DefaultListTransaction(ctx context.Context, db *gorm.DB) ([]*Transaction, error) {
	in := Transaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionORM{}, &Transaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("transaction_id")
	ormResponse := []TransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Transaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionORM) error
}

// DefaultCreateScheduler executes a basic gorm create call
func DefaultCreateScheduler(ctx context.Context, in *Scheduler, db *gorm.DB) (*Scheduler, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SchedulerORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadScheduler(ctx context.Context, in *Scheduler, db *gorm.DB) (*Scheduler, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.SchedulerId == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SchedulerORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SchedulerORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SchedulerORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SchedulerORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteScheduler(ctx context.Context, in *Scheduler, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.SchedulerId == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SchedulerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SchedulerORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSchedulerSet(ctx context.Context, in []*Scheduler, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.SchedulerId == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.SchedulerId)
	}
	if hook, ok := (interface{}(&SchedulerORM{})).(SchedulerORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("scheduler_id in (?)", keys).Delete(&SchedulerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SchedulerORM{})).(SchedulerORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SchedulerORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Scheduler, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Scheduler, *gorm.DB) error
}

// DefaultStrictUpdateScheduler clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateScheduler(ctx context.Context, in *Scheduler, db *gorm.DB) (*Scheduler, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateScheduler")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SchedulerORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("scheduler_id=?", ormObj.SchedulerId).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SchedulerORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchScheduler executes a basic gorm update call with patch behavior
func DefaultPatchScheduler(ctx context.Context, in *Scheduler, updateMask *field_mask.FieldMask, db *gorm.DB) (*Scheduler, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Scheduler
	var err error
	if hook, ok := interface{}(&pbObj).(SchedulerWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(SchedulerWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskScheduler(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SchedulerWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateScheduler(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SchedulerWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SchedulerWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Scheduler, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SchedulerWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Scheduler, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SchedulerWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Scheduler, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SchedulerWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Scheduler, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetScheduler executes a bulk gorm update call with patch behavior
func DefaultPatchSetScheduler(ctx context.Context, objects []*Scheduler, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Scheduler, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Scheduler, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchScheduler(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskScheduler patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskScheduler(ctx context.Context, patchee *Scheduler, patcher *Scheduler, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Scheduler, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransaction bool
	var updatedScheduleDate bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"SchedulerId" {
			patchee.SchedulerId = patcher.SchedulerId
			continue
		}
		if !updatedTransaction && strings.HasPrefix(f, prefix+"Transaction.") {
			updatedTransaction = true
			if patcher.Transaction == nil {
				patchee.Transaction = nil
				continue
			}
			if patchee.Transaction == nil {
				patchee.Transaction = &Transaction{}
			}
			if o, err := DefaultApplyFieldMaskTransaction(ctx, patchee.Transaction, patcher.Transaction, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Transaction.", db); err != nil {
				return nil, err
			} else {
				patchee.Transaction = o
			}
			continue
		}
		if f == prefix+"Transaction" {
			updatedTransaction = true
			patchee.Transaction = patcher.Transaction
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedScheduleDate && strings.HasPrefix(f, prefix+"ScheduleDate.") {
			if patcher.ScheduleDate == nil {
				patchee.ScheduleDate = nil
				continue
			}
			if patchee.ScheduleDate == nil {
				patchee.ScheduleDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ScheduleDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ScheduleDate, patchee.ScheduleDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ScheduleDate" {
			updatedScheduleDate = true
			patchee.ScheduleDate = patcher.ScheduleDate
			continue
		}
		if f == prefix+"IsCutOff" {
			patchee.IsCutOff = patcher.IsCutOff
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListScheduler executes a gorm list call
func DefaultListScheduler(ctx context.Context, db *gorm.DB) ([]*Scheduler, error) {
	in := Scheduler{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SchedulerORM{}, &Scheduler{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("scheduler_id")
	ormResponse := []SchedulerORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SchedulerORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Scheduler{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SchedulerORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SchedulerORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SchedulerORM) error
}

// DefaultCreateHostToHostConfig executes a basic gorm create call
func DefaultCreateHostToHostConfig(ctx context.Context, in *HostToHostConfig, db *gorm.DB) (*HostToHostConfig, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HostToHostConfigORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHostToHostConfig(ctx context.Context, in *HostToHostConfig, db *gorm.DB) (*HostToHostConfig, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.ConfigId == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HostToHostConfigORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HostToHostConfigORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HostToHostConfigORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HostToHostConfigORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHostToHostConfig(ctx context.Context, in *HostToHostConfig, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.ConfigId == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HostToHostConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HostToHostConfigORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHostToHostConfigSet(ctx context.Context, in []*HostToHostConfig, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.ConfigId == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.ConfigId)
	}
	if hook, ok := (interface{}(&HostToHostConfigORM{})).(HostToHostConfigORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("config_id in (?)", keys).Delete(&HostToHostConfigORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HostToHostConfigORM{})).(HostToHostConfigORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HostToHostConfigORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HostToHostConfig, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HostToHostConfig, *gorm.DB) error
}

// DefaultStrictUpdateHostToHostConfig clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHostToHostConfig(ctx context.Context, in *HostToHostConfig, db *gorm.DB) (*HostToHostConfig, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHostToHostConfig")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HostToHostConfigORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("config_id=?", ormObj.ConfigId).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HostToHostConfigORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHostToHostConfig executes a basic gorm update call with patch behavior
func DefaultPatchHostToHostConfig(ctx context.Context, in *HostToHostConfig, updateMask *field_mask.FieldMask, db *gorm.DB) (*HostToHostConfig, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj HostToHostConfig
	var err error
	if hook, ok := interface{}(&pbObj).(HostToHostConfigWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(HostToHostConfigWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHostToHostConfig(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HostToHostConfigWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHostToHostConfig(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HostToHostConfigWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HostToHostConfigWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HostToHostConfig, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HostToHostConfig, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HostToHostConfig, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HostToHostConfig, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHostToHostConfig executes a bulk gorm update call with patch behavior
func DefaultPatchSetHostToHostConfig(ctx context.Context, objects []*HostToHostConfig, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*HostToHostConfig, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HostToHostConfig, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHostToHostConfig(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHostToHostConfig patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHostToHostConfig(ctx context.Context, patchee *HostToHostConfig, patcher *HostToHostConfig, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HostToHostConfig, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"ConfigId" {
			patchee.ConfigId = patcher.ConfigId
			continue
		}
		if f == prefix+"DirectoryUrl" {
			patchee.DirectoryUrl = patcher.DirectoryUrl
			continue
		}
		if f == prefix+"DirectoryUsername" {
			patchee.DirectoryUsername = patcher.DirectoryUsername
			continue
		}
		if f == prefix+"DirectoryPassword" {
			patchee.DirectoryPassword = patcher.DirectoryPassword
			continue
		}
		if f == prefix+"HostToHostUserId" {
			patchee.HostToHostUserId = patcher.HostToHostUserId
			continue
		}
		if f == prefix+"Encryption" {
			patchee.Encryption = patcher.Encryption
			continue
		}
		if f == prefix+"EncryptionPrivateKey" {
			patchee.EncryptionPrivateKey = patcher.EncryptionPrivateKey
			continue
		}
		if f == prefix+"EncryptionPublicKey" {
			patchee.EncryptionPublicKey = patcher.EncryptionPublicKey
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHostToHostConfig executes a gorm list call
func DefaultListHostToHostConfig(ctx context.Context, db *gorm.DB) ([]*HostToHostConfig, error) {
	in := HostToHostConfig{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HostToHostConfigORM{}, &HostToHostConfig{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("config_id")
	ormResponse := []HostToHostConfigORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HostToHostConfigORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HostToHostConfig{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HostToHostConfigORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HostToHostConfigORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HostToHostConfigORM) error
}
