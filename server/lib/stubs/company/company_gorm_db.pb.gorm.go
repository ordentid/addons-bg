package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserORM struct {
	CreatedAt *time.Time
	DeletedAt *time.Time
	Id        uint64 `gorm:"primary_key;not null"`
	Password  string `gorm:"not null"`
	Role      string `gorm:"default:user;not null"`
	UpdatedAt *time.Time
	Username  string `gorm:"unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type CompanyORM struct {
	CompanyGroupLimits  []*CompanyGroupLimitORM `gorm:"foreignkey:HoldingCompanyID;association_foreignkey:CompanyID"`
	CompanyID           uint64                  `gorm:"column:CompanyID;primary_key;not null;auto_increment"`
	CompanyLimits       []*CompanyLimitORM      `gorm:"foreignkey:CompanyID;association_foreignkey:CompanyID"`
	CompanyName         string                  `gorm:"column:CompanyName;type:varchar(255)"`
	CreatedAt           *time.Time              `gorm:"not null"`
	CreatedByID         uint64                  `gorm:"column:CreatedByID;not null"`
	GroupName           string                  `gorm:"column:GroupName;type:varchar(255)"`
	HoldingCompanyName  string                  `gorm:"column:HoldingCompany;not null"`
	HoldingID           uint64                  `gorm:"column:HoldingID;not null"`
	SubsidiaryCompanies []*CompanyORM           `gorm:"foreignkey:HoldingID;association_foreignkey:CompanyID"`
	UpdatedAt           *time.Time              `gorm:"not null"`
	UpdatedByID         uint64                  `gorm:"column:UpdatedByID;not null"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyORM) TableName() string {
	return "companies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Company) ToORM(ctx context.Context) (CompanyORM, error) {
	to := CompanyORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.HoldingID = m.HoldingID
	to.GroupName = m.GroupName
	to.CompanyName = m.CompanyName
	to.HoldingCompanyName = m.HoldingCompanyName
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	for _, v := range m.CompanyLimits {
		if v != nil {
			if tempCompanyLimits, cErr := v.ToORM(ctx); cErr == nil {
				to.CompanyLimits = append(to.CompanyLimits, &tempCompanyLimits)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyLimits = append(to.CompanyLimits, nil)
		}
	}
	for _, v := range m.CompanyGroupLimits {
		if v != nil {
			if tempCompanyGroupLimits, cErr := v.ToORM(ctx); cErr == nil {
				to.CompanyGroupLimits = append(to.CompanyGroupLimits, &tempCompanyGroupLimits)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyGroupLimits = append(to.CompanyGroupLimits, nil)
		}
	}
	for _, v := range m.SubsidiaryCompanies {
		if v != nil {
			if tempSubsidiaryCompanies, cErr := v.ToORM(ctx); cErr == nil {
				to.SubsidiaryCompanies = append(to.SubsidiaryCompanies, &tempSubsidiaryCompanies)
			} else {
				return to, cErr
			}
		} else {
			to.SubsidiaryCompanies = append(to.SubsidiaryCompanies, nil)
		}
	}
	if posthook, ok := interface{}(m).(CompanyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyORM) ToPB(ctx context.Context) (Company, error) {
	to := Company{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.HoldingID = m.HoldingID
	to.GroupName = m.GroupName
	to.CompanyName = m.CompanyName
	to.HoldingCompanyName = m.HoldingCompanyName
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	for _, v := range m.CompanyLimits {
		if v != nil {
			if tempCompanyLimits, cErr := v.ToPB(ctx); cErr == nil {
				to.CompanyLimits = append(to.CompanyLimits, &tempCompanyLimits)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyLimits = append(to.CompanyLimits, nil)
		}
	}
	for _, v := range m.CompanyGroupLimits {
		if v != nil {
			if tempCompanyGroupLimits, cErr := v.ToPB(ctx); cErr == nil {
				to.CompanyGroupLimits = append(to.CompanyGroupLimits, &tempCompanyGroupLimits)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyGroupLimits = append(to.CompanyGroupLimits, nil)
		}
	}
	for _, v := range m.SubsidiaryCompanies {
		if v != nil {
			if tempSubsidiaryCompanies, cErr := v.ToPB(ctx); cErr == nil {
				to.SubsidiaryCompanies = append(to.SubsidiaryCompanies, &tempSubsidiaryCompanies)
			} else {
				return to, cErr
			}
		} else {
			to.SubsidiaryCompanies = append(to.SubsidiaryCompanies, nil)
		}
	}
	if posthook, ok := interface{}(m).(CompanyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Company the arg will be the target, the caller the one being converted from

// CompanyBeforeToORM called before default ToORM code
type CompanyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyORM) error
}

// CompanyAfterToORM called after default ToORM code
type CompanyWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyORM) error
}

// CompanyBeforeToPB called before default ToPB code
type CompanyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Company) error
}

// CompanyAfterToPB called after default ToPB code
type CompanyWithAfterToPB interface {
	AfterToPB(context.Context, *Company) error
}

type CompanyGroupLimitORM struct {
	CreatedAt        *time.Time   `gorm:"not null"`
	CreatedByID      uint64       `gorm:"column:CreatedByID;not null"`
	Currency         *CurrencyORM `gorm:"foreignkey:CurrencyID;association_foreignkey:CurrencyID;preload:true"`
	CurrencyID       uint64       `gorm:"column:CurrencyID;primary_key;not null"`
	HoldingCompanyID uint64       `gorm:"column:HoldingCompanyID;primary_key;not null"`
	Limit            uint64       `gorm:"column:Limit;type:bigint;not null"`
	UpdatedAt        *time.Time   `gorm:"not null"`
	UpdatedByID      uint64       `gorm:"column:UpdatedByID;not null"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyGroupLimitORM) TableName() string {
	return "company_group_limits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyGroupLimit) ToORM(ctx context.Context) (CompanyGroupLimitORM, error) {
	to := CompanyGroupLimitORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyGroupLimitWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.HoldingCompanyID = m.HoldingCompanyID
	to.CurrencyID = m.CurrencyID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if posthook, ok := interface{}(m).(CompanyGroupLimitWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyGroupLimitORM) ToPB(ctx context.Context) (CompanyGroupLimit, error) {
	to := CompanyGroupLimit{}
	var err error
	if prehook, ok := interface{}(m).(CompanyGroupLimitWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.HoldingCompanyID = m.HoldingCompanyID
	to.CurrencyID = m.CurrencyID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if posthook, ok := interface{}(m).(CompanyGroupLimitWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyGroupLimit the arg will be the target, the caller the one being converted from

// CompanyGroupLimitBeforeToORM called before default ToORM code
type CompanyGroupLimitWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyGroupLimitORM) error
}

// CompanyGroupLimitAfterToORM called after default ToORM code
type CompanyGroupLimitWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyGroupLimitORM) error
}

// CompanyGroupLimitBeforeToPB called before default ToPB code
type CompanyGroupLimitWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyGroupLimit) error
}

// CompanyGroupLimitAfterToPB called after default ToPB code
type CompanyGroupLimitWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyGroupLimit) error
}

type CompanyLimitORM struct {
	CompanyID   uint64       `gorm:"column:CompanyID;primary_key;not null"`
	CreatedAt   *time.Time   `gorm:"not null"`
	CreatedByID uint64       `gorm:"column:CreatedByID;not null"`
	Currency    *CurrencyORM `gorm:"foreignkey:CurrencyID;association_foreignkey:CurrencyID;preload:true"`
	CurrencyID  uint64       `gorm:"column:CurrencyID;primary_key;not null"`
	Limit       uint64       `gorm:"column:Limit;type:bigint;not null"`
	UpdatedAt   *time.Time   `gorm:"not null"`
	UpdatedByID uint64       `gorm:"column:UpdatedByID;not null"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyLimitORM) TableName() string {
	return "company_limits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyLimit) ToORM(ctx context.Context) (CompanyLimitORM, error) {
	to := CompanyLimitORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyLimitWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.CurrencyID = m.CurrencyID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if posthook, ok := interface{}(m).(CompanyLimitWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyLimitORM) ToPB(ctx context.Context) (CompanyLimit, error) {
	to := CompanyLimit{}
	var err error
	if prehook, ok := interface{}(m).(CompanyLimitWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.CurrencyID = m.CurrencyID
	if m.Currency != nil {
		tempCurrency, err := m.Currency.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Currency = &tempCurrency
	}
	to.Limit = m.Limit
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if posthook, ok := interface{}(m).(CompanyLimitWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyLimit the arg will be the target, the caller the one being converted from

// CompanyLimitBeforeToORM called before default ToORM code
type CompanyLimitWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyLimitORM) error
}

// CompanyLimitAfterToORM called after default ToORM code
type CompanyLimitWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyLimitORM) error
}

// CompanyLimitBeforeToPB called before default ToPB code
type CompanyLimitWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyLimit) error
}

// CompanyLimitAfterToPB called after default ToPB code
type CompanyLimitWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyLimit) error
}

type CurrencyORM struct {
	Code        string     `gorm:"column:Code;type:varchar(255);not null"`
	CreatedAt   *time.Time `gorm:"not null"`
	CreatedByID uint64     `gorm:"column:CreatedByID;not null"`
	CurrencyID  uint64     `gorm:"column:CurrencyID;primary_key;not null;auto_increment"`
	Name        string     `gorm:"column:Name;type:varchar(255);not null"`
	UpdatedAt   *time.Time `gorm:"not null"`
	UpdatedByID uint64     `gorm:"column:UpdatedByID;not null"`
}

// TableName overrides the default tablename generated by GORM
func (CurrencyORM) TableName() string {
	return "currencies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Currency) ToORM(ctx context.Context) (CurrencyORM, error) {
	to := CurrencyORM{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CurrencyID = m.CurrencyID
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if posthook, ok := interface{}(m).(CurrencyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CurrencyORM) ToPB(ctx context.Context) (Currency, error) {
	to := Currency{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CurrencyID = m.CurrencyID
	to.Name = m.Name
	to.Code = m.Code
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if posthook, ok := interface{}(m).(CurrencyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Currency the arg will be the target, the caller the one being converted from

// CurrencyBeforeToORM called before default ToORM code
type CurrencyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CurrencyORM) error
}

// CurrencyAfterToORM called after default ToORM code
type CurrencyWithAfterToORM interface {
	AfterToORM(context.Context, *CurrencyORM) error
}

// CurrencyBeforeToPB called before default ToPB code
type CurrencyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Currency) error
}

// CurrencyAfterToPB called after default ToPB code
type CurrencyWithAfterToPB interface {
	AfterToPB(context.Context, *Currency) error
}

type GroupIDStoreORM struct {
	CompanyID uint64 `gorm:"column:CompanyID;primary_key;not null;auto_increment"`
	Ids       string `gorm:"column:IDS;type:jsonb"`
}

// TableName overrides the default tablename generated by GORM
func (GroupIDStoreORM) TableName() string {
	return "group_id_store"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *GroupIDStore) ToORM(ctx context.Context) (GroupIDStoreORM, error) {
	to := GroupIDStoreORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupIDStoreWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.Ids = m.Ids
	if posthook, ok := interface{}(m).(GroupIDStoreWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupIDStoreORM) ToPB(ctx context.Context) (GroupIDStore, error) {
	to := GroupIDStore{}
	var err error
	if prehook, ok := interface{}(m).(GroupIDStoreWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.Ids = m.Ids
	if posthook, ok := interface{}(m).(GroupIDStoreWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type GroupIDStore the arg will be the target, the caller the one being converted from

// GroupIDStoreBeforeToORM called before default ToORM code
type GroupIDStoreWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupIDStoreORM) error
}

// GroupIDStoreAfterToORM called after default ToORM code
type GroupIDStoreWithAfterToORM interface {
	AfterToORM(context.Context, *GroupIDStoreORM) error
}

// GroupIDStoreBeforeToPB called before default ToPB code
type GroupIDStoreWithBeforeToPB interface {
	BeforeToPB(context.Context, *GroupIDStore) error
}

// GroupIDStoreAfterToPB called after default ToPB code
type GroupIDStoreWithAfterToPB interface {
	AfterToPB(context.Context, *GroupIDStore) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateCompany executes a basic gorm create call
func DefaultCreateCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompany(ctx context.Context, in *Company, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanySet(ctx context.Context, in []*Company, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CompanyID)
	}
	if hook, ok := (interface{}(&CompanyORM{})).(CompanyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("company_id in (?)", keys).Delete(&CompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyORM{})).(CompanyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Company, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Company, *gorm.DB) error
}

// DefaultStrictUpdateCompany clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompany")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("CompanyID=?", ormObj.CompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCompanyGroupLimits := CompanyGroupLimitORM{}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompanyGroupLimits.HoldingCompanyID = ormObj.CompanyID
	if err = db.Where(filterCompanyGroupLimits).Delete(CompanyGroupLimitORM{}).Error; err != nil {
		return nil, err
	}
	filterCompanyLimits := CompanyLimitORM{}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompanyLimits.CompanyID = ormObj.CompanyID
	if err = db.Where(filterCompanyLimits).Delete(CompanyLimitORM{}).Error; err != nil {
		return nil, err
	}
	filterSubsidiaryCompanies := CompanyORM{}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	filterSubsidiaryCompanies.HoldingID = ormObj.CompanyID
	if err = db.Where(filterSubsidiaryCompanies).Delete(CompanyORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompany executes a basic gorm update call with patch behavior
func DefaultPatchCompany(ctx context.Context, in *Company, updateMask *field_mask.FieldMask, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Company
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompany(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompany(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompany executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompany(ctx context.Context, objects []*Company, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Company, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Company, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompany(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompany patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompany(ctx context.Context, patchee *Company, patcher *Company, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Company, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"HoldingID" {
			patchee.HoldingID = patcher.HoldingID
			continue
		}
		if f == prefix+"GroupName" {
			patchee.GroupName = patcher.GroupName
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"HoldingCompanyName" {
			patchee.HoldingCompanyName = patcher.HoldingCompanyName
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"CompanyLimits" {
			patchee.CompanyLimits = patcher.CompanyLimits
			continue
		}
		if f == prefix+"CompanyGroupLimits" {
			patchee.CompanyGroupLimits = patcher.CompanyGroupLimits
			continue
		}
		if f == prefix+"SubsidiaryCompanies" {
			patchee.SubsidiaryCompanies = patcher.SubsidiaryCompanies
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompany executes a gorm list call
func DefaultListCompany(ctx context.Context, db *gorm.DB) ([]*Company, error) {
	in := Company{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyORM{}, &Company{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("CompanyID")
	ormResponse := []CompanyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Company{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyORM) error
}

// DefaultCreateCompanyGroupLimit executes a basic gorm create call
func DefaultCreateCompanyGroupLimit(ctx context.Context, in *CompanyGroupLimit, db *gorm.DB) (*CompanyGroupLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyGroupLimitORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyGroupLimit(ctx context.Context, in *CompanyGroupLimit, db *gorm.DB) (*CompanyGroupLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.HoldingCompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyGroupLimitORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyGroupLimitORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyGroupLimitORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyGroupLimitORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyGroupLimit(ctx context.Context, in *CompanyGroupLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.HoldingCompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyGroupLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyGroupLimitORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyGroupLimitSet(ctx context.Context, in []*CompanyGroupLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.HoldingCompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.HoldingCompanyID)
	}
	if hook, ok := (interface{}(&CompanyGroupLimitORM{})).(CompanyGroupLimitORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("holding_company_id in (?)", keys).Delete(&CompanyGroupLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyGroupLimitORM{})).(CompanyGroupLimitORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyGroupLimitORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyGroupLimit, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyGroupLimit, *gorm.DB) error
}

// DefaultStrictUpdateCompanyGroupLimit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyGroupLimit(ctx context.Context, in *CompanyGroupLimit, db *gorm.DB) (*CompanyGroupLimit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyGroupLimit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyGroupLimitORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("HoldingCompanyID=?", ormObj.HoldingCompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyGroupLimitORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyGroupLimit executes a basic gorm update call with patch behavior
func DefaultPatchCompanyGroupLimit(ctx context.Context, in *CompanyGroupLimit, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyGroupLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyGroupLimit
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyGroupLimitWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyGroupLimitWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyGroupLimit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyGroupLimitWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyGroupLimit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyGroupLimitWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyGroupLimitWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyGroupLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyGroupLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyGroupLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyGroupLimit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyGroupLimit executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyGroupLimit(ctx context.Context, objects []*CompanyGroupLimit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyGroupLimit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyGroupLimit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyGroupLimit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyGroupLimit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyGroupLimit(ctx context.Context, patchee *CompanyGroupLimit, patcher *CompanyGroupLimit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyGroupLimit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCurrency bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"HoldingCompanyID" {
			patchee.HoldingCompanyID = patcher.HoldingCompanyID
			continue
		}
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
		if !updatedCurrency && strings.HasPrefix(f, prefix+"Currency.") {
			updatedCurrency = true
			if patcher.Currency == nil {
				patchee.Currency = nil
				continue
			}
			if patchee.Currency == nil {
				patchee.Currency = &Currency{}
			}
			if o, err := DefaultApplyFieldMaskCurrency(ctx, patchee.Currency, patcher.Currency, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Currency.", db); err != nil {
				return nil, err
			} else {
				patchee.Currency = o
			}
			continue
		}
		if f == prefix+"Currency" {
			updatedCurrency = true
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Limit" {
			patchee.Limit = patcher.Limit
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyGroupLimit executes a gorm list call
func DefaultListCompanyGroupLimit(ctx context.Context, db *gorm.DB) ([]*CompanyGroupLimit, error) {
	in := CompanyGroupLimit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyGroupLimitORM{}, &CompanyGroupLimit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("HoldingCompanyID")
	ormResponse := []CompanyGroupLimitORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyGroupLimitORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyGroupLimit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyGroupLimitORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyGroupLimitORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyGroupLimitORM) error
}

// DefaultCreateCompanyLimit executes a basic gorm create call
func DefaultCreateCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyLimitORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyLimitORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyLimitORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyLimitORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyLimitORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CurrencyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyLimitORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyLimitSet(ctx context.Context, in []*CompanyLimit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CompanyID)
	}
	if hook, ok := (interface{}(&CompanyLimitORM{})).(CompanyLimitORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("company_id in (?)", keys).Delete(&CompanyLimitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyLimitORM{})).(CompanyLimitORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyLimitORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyLimit, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyLimit, *gorm.DB) error
}

// DefaultStrictUpdateCompanyLimit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyLimit(ctx context.Context, in *CompanyLimit, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyLimit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyLimitORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("CurrencyID=?", ormObj.CurrencyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyLimitORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyLimit executes a basic gorm update call with patch behavior
func DefaultPatchCompanyLimit(ctx context.Context, in *CompanyLimit, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyLimit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyLimit
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyLimitWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyLimitWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyLimit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyLimitWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyLimit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyLimitWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyLimitWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyLimit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyLimit executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyLimit(ctx context.Context, objects []*CompanyLimit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyLimit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyLimit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyLimit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyLimit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyLimit(ctx context.Context, patchee *CompanyLimit, patcher *CompanyLimit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyLimit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCurrency bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
		if !updatedCurrency && strings.HasPrefix(f, prefix+"Currency.") {
			updatedCurrency = true
			if patcher.Currency == nil {
				patchee.Currency = nil
				continue
			}
			if patchee.Currency == nil {
				patchee.Currency = &Currency{}
			}
			if o, err := DefaultApplyFieldMaskCurrency(ctx, patchee.Currency, patcher.Currency, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Currency.", db); err != nil {
				return nil, err
			} else {
				patchee.Currency = o
			}
			continue
		}
		if f == prefix+"Currency" {
			updatedCurrency = true
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Limit" {
			patchee.Limit = patcher.Limit
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyLimit executes a gorm list call
func DefaultListCompanyLimit(ctx context.Context, db *gorm.DB) ([]*CompanyLimit, error) {
	in := CompanyLimit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyLimitORM{}, &CompanyLimit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("CompanyID")
	ormResponse := []CompanyLimitORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyLimitORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyLimit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyLimitORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyLimitORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyLimitORM) error
}

// DefaultCreateCurrency executes a basic gorm create call
func DefaultCreateCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CurrencyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CurrencyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CurrencyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CurrencyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCurrency(ctx context.Context, in *Currency, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CurrencyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CurrencyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCurrencySet(ctx context.Context, in []*Currency, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CurrencyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CurrencyID)
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("currency_id in (?)", keys).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CurrencyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Currency, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Currency, *gorm.DB) error
}

// DefaultStrictUpdateCurrency clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCurrency(ctx context.Context, in *Currency, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCurrency")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CurrencyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("CurrencyID=?", ormObj.CurrencyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CurrencyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCurrency executes a basic gorm update call with patch behavior
func DefaultPatchCurrency(ctx context.Context, in *Currency, updateMask *field_mask.FieldMask, db *gorm.DB) (*Currency, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Currency
	var err error
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCurrency(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCurrency(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CurrencyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CurrencyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CurrencyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Currency, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCurrency executes a bulk gorm update call with patch behavior
func DefaultPatchSetCurrency(ctx context.Context, objects []*Currency, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Currency, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Currency, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCurrency(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCurrency patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCurrency(ctx context.Context, patchee *Currency, patcher *Currency, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Currency, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"CurrencyID" {
			patchee.CurrencyID = patcher.CurrencyID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCurrency executes a gorm list call
func DefaultListCurrency(ctx context.Context, db *gorm.DB) ([]*Currency, error) {
	in := Currency{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CurrencyORM{}, &Currency{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("CurrencyID")
	ormResponse := []CurrencyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Currency{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CurrencyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CurrencyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CurrencyORM) error
}

// DefaultCreateGroupIDStore executes a basic gorm create call
func DefaultCreateGroupIDStore(ctx context.Context, in *GroupIDStore, db *gorm.DB) (*GroupIDStore, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupIDStoreORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadGroupIDStore(ctx context.Context, in *GroupIDStore, db *gorm.DB) (*GroupIDStore, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &GroupIDStoreORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupIDStoreORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupIDStoreORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupIDStoreORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupIDStore(ctx context.Context, in *GroupIDStore, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupIDStoreORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupIDStoreORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupIDStoreSet(ctx context.Context, in []*GroupIDStore, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CompanyID)
	}
	if hook, ok := (interface{}(&GroupIDStoreORM{})).(GroupIDStoreORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("company_id in (?)", keys).Delete(&GroupIDStoreORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupIDStoreORM{})).(GroupIDStoreORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupIDStoreORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*GroupIDStore, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*GroupIDStore, *gorm.DB) error
}

// DefaultStrictUpdateGroupIDStore clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroupIDStore(ctx context.Context, in *GroupIDStore, db *gorm.DB) (*GroupIDStore, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroupIDStore")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &GroupIDStoreORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("CompanyID=?", ormObj.CompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupIDStoreORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchGroupIDStore executes a basic gorm update call with patch behavior
func DefaultPatchGroupIDStore(ctx context.Context, in *GroupIDStore, updateMask *field_mask.FieldMask, db *gorm.DB) (*GroupIDStore, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj GroupIDStore
	var err error
	if hook, ok := interface{}(&pbObj).(GroupIDStoreWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(GroupIDStoreWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroupIDStore(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupIDStoreWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroupIDStore(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupIDStoreWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupIDStoreWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *GroupIDStore, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *GroupIDStore, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *GroupIDStore, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *GroupIDStore, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetGroupIDStore executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroupIDStore(ctx context.Context, objects []*GroupIDStore, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*GroupIDStore, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*GroupIDStore, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroupIDStore(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroupIDStore patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroupIDStore(ctx context.Context, patchee *GroupIDStore, patcher *GroupIDStore, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*GroupIDStore, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Ids" {
			patchee.Ids = patcher.Ids
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroupIDStore executes a gorm list call
func DefaultListGroupIDStore(ctx context.Context, db *gorm.DB) ([]*GroupIDStore, error) {
	in := GroupIDStore{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &GroupIDStoreORM{}, &GroupIDStore{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("CompanyID")
	ormResponse := []GroupIDStoreORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupIDStoreORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*GroupIDStore{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupIDStoreORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupIDStoreORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]GroupIDStoreORM) error
}
