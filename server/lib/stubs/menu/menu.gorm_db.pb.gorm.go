package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserORM struct {
	CreatedAt *time.Time
	DeletedAt *time.Time
	Id        uint64 `gorm:"primary_key;not null"`
	Password  string `gorm:"not null"`
	Role      string `gorm:"default:user;not null"`
	UpdatedAt *time.Time
	Username  string `gorm:"unique;not null"`
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Username = m.Username
	to.Password = m.Password
	to.Role = m.Role
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type ModuleORM struct {
	CreatedAt       *time.Time
	IsTransactional bool
	ModuleID        uint64 `gorm:"primary_key;not null"`
	Name            string `gorm:"type:varchar(255)"`
}

// TableName overrides the default tablename generated by GORM
func (ModuleORM) TableName() string {
	return "modules"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Module) ToORM(ctx context.Context) (ModuleORM, error) {
	to := ModuleORM{}
	var err error
	if prehook, ok := interface{}(m).(ModuleWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ModuleID = m.ModuleID
	to.Name = m.Name
	to.IsTransactional = m.IsTransactional
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(ModuleWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ModuleORM) ToPB(ctx context.Context) (Module, error) {
	to := Module{}
	var err error
	if prehook, ok := interface{}(m).(ModuleWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.ModuleID = m.ModuleID
	to.Name = m.Name
	to.IsTransactional = m.IsTransactional
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(ModuleWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Module the arg will be the target, the caller the one being converted from

// ModuleBeforeToORM called before default ToORM code
type ModuleWithBeforeToORM interface {
	BeforeToORM(context.Context, *ModuleORM) error
}

// ModuleAfterToORM called after default ToORM code
type ModuleWithAfterToORM interface {
	AfterToORM(context.Context, *ModuleORM) error
}

// ModuleBeforeToPB called before default ToPB code
type ModuleWithBeforeToPB interface {
	BeforeToPB(context.Context, *Module) error
}

// ModuleAfterToPB called after default ToPB code
type ModuleWithAfterToPB interface {
	AfterToPB(context.Context, *Module) error
}

type MenuORM struct {
	CreatedAt       *time.Time
	CreatedByID     uint64
	DeletedAt       *time.Time
	DeletedByID     uint64
	Disables        []*MenuDisableORM `gorm:"foreignkey:MenuID;association_foreignkey:MenuID;preload:true"`
	EnableScheduled bool
	IconURI         string `gorm:"type:text"`
	IsEnable        bool
	IsModule        bool
	IsTransactional bool
	Label           string     `gorm:"type:varchar(255)"`
	MenuID          uint64     `gorm:"column:MenuID;primary_key;not null"`
	Menus           []*MenuORM `gorm:"foreignkey:ParentID;association_foreignkey:MenuID;preload:true"`
	Name            string     `gorm:"type:varchar(255)"`
	OrderNumber     string     `gorm:"column:OrderNumber;not null"`
	ParentID        uint64     `gorm:"column:ParentID"`
	ProductID       uint64
	ProductName     string
	RootPath        string `gorm:"type:varchar(255)"`
	UpdatedAt       *time.Time
	UpdatedByID     uint64
	UserType        string `gorm:"type:varchar(255)"`
}

// TableName overrides the default tablename generated by GORM
func (MenuORM) TableName() string {
	return "menus"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Menu) ToORM(ctx context.Context) (MenuORM, error) {
	to := MenuORM{}
	var err error
	if prehook, ok := interface{}(m).(MenuWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MenuID = m.MenuID
	to.ParentID = m.ParentID
	to.UserType = m.UserType
	to.Label = m.Label
	to.IsModule = m.IsModule
	to.RootPath = m.RootPath
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.Menus {
		if v != nil {
			if tempMenus, cErr := v.ToORM(ctx); cErr == nil {
				to.Menus = append(to.Menus, &tempMenus)
			} else {
				return to, cErr
			}
		} else {
			to.Menus = append(to.Menus, nil)
		}
	}
	to.ProductID = m.ProductID
	to.ProductName = m.ProductName
	to.IsTransactional = m.IsTransactional
	to.OrderNumber = m.OrderNumber
	to.IconURI = m.IconURI
	to.Name = m.Name
	to.IsEnable = m.IsEnable
	to.EnableScheduled = m.EnableScheduled
	for _, v := range m.Disables {
		if v != nil {
			if tempDisables, cErr := v.ToORM(ctx); cErr == nil {
				to.Disables = append(to.Disables, &tempDisables)
			} else {
				return to, cErr
			}
		} else {
			to.Disables = append(to.Disables, nil)
		}
	}
	if posthook, ok := interface{}(m).(MenuWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MenuORM) ToPB(ctx context.Context) (Menu, error) {
	to := Menu{}
	var err error
	if prehook, ok := interface{}(m).(MenuWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MenuID = m.MenuID
	to.ParentID = m.ParentID
	to.UserType = m.UserType
	to.Label = m.Label
	to.IsModule = m.IsModule
	to.RootPath = m.RootPath
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	for _, v := range m.Menus {
		if v != nil {
			if tempMenus, cErr := v.ToPB(ctx); cErr == nil {
				to.Menus = append(to.Menus, &tempMenus)
			} else {
				return to, cErr
			}
		} else {
			to.Menus = append(to.Menus, nil)
		}
	}
	to.ProductID = m.ProductID
	to.ProductName = m.ProductName
	to.IsTransactional = m.IsTransactional
	to.OrderNumber = m.OrderNumber
	to.IconURI = m.IconURI
	to.Name = m.Name
	to.IsEnable = m.IsEnable
	to.EnableScheduled = m.EnableScheduled
	for _, v := range m.Disables {
		if v != nil {
			if tempDisables, cErr := v.ToPB(ctx); cErr == nil {
				to.Disables = append(to.Disables, &tempDisables)
			} else {
				return to, cErr
			}
		} else {
			to.Disables = append(to.Disables, nil)
		}
	}
	if posthook, ok := interface{}(m).(MenuWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Menu the arg will be the target, the caller the one being converted from

// MenuBeforeToORM called before default ToORM code
type MenuWithBeforeToORM interface {
	BeforeToORM(context.Context, *MenuORM) error
}

// MenuAfterToORM called after default ToORM code
type MenuWithAfterToORM interface {
	AfterToORM(context.Context, *MenuORM) error
}

// MenuBeforeToPB called before default ToPB code
type MenuWithBeforeToPB interface {
	BeforeToPB(context.Context, *Menu) error
}

// MenuAfterToPB called after default ToPB code
type MenuWithAfterToPB interface {
	AfterToPB(context.Context, *Menu) error
}

type MenuDisableORM struct {
	CreatedAt     *time.Time
	CreatedByID   uint64
	CustomTime    string `gorm:"type:jsonb"`
	DeletedAt     *time.Time
	DeletedByID   uint64
	EndDateTime   *time.Time
	Menu          *MenuORM `gorm:"foreignkey:MenuId;association_foreignkey:MenuID"`
	MenuDisableID uint64   `gorm:"column:MenuDisableID;primary_key;not null"`
	MenuID        uint64   `gorm:"column:MenuID;not null"`
	MenuId        uint64   `gorm:"column:menu_id;not null"`
	StartDateTime *time.Time
	UpdatedAt     *time.Time
	UpdatedByID   uint64
}

// TableName overrides the default tablename generated by GORM
func (MenuDisableORM) TableName() string {
	return "menu_disables"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MenuDisable) ToORM(ctx context.Context) (MenuDisableORM, error) {
	to := MenuDisableORM{}
	var err error
	if prehook, ok := interface{}(m).(MenuDisableWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MenuDisableID = m.MenuDisableID
	if m.Menu != nil {
		tempMenu, err := m.Menu.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Menu = &tempMenu
	}
	if m.StartDateTime != nil {
		t := m.StartDateTime.AsTime()
		to.StartDateTime = &t
	}
	if m.EndDateTime != nil {
		t := m.EndDateTime.AsTime()
		to.EndDateTime = &t
	}
	to.CustomTime = m.CustomTime
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	to.DeletedByID = m.DeletedByID
	to.MenuID = m.MenuID
	if posthook, ok := interface{}(m).(MenuDisableWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MenuDisableORM) ToPB(ctx context.Context) (MenuDisable, error) {
	to := MenuDisable{}
	var err error
	if prehook, ok := interface{}(m).(MenuDisableWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MenuDisableID = m.MenuDisableID
	if m.Menu != nil {
		tempMenu, err := m.Menu.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Menu = &tempMenu
	}
	if m.StartDateTime != nil {
		to.StartDateTime = timestamppb.New(*m.StartDateTime)
	}
	if m.EndDateTime != nil {
		to.EndDateTime = timestamppb.New(*m.EndDateTime)
	}
	to.CustomTime = m.CustomTime
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	to.DeletedByID = m.DeletedByID
	to.MenuID = m.MenuID
	if posthook, ok := interface{}(m).(MenuDisableWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MenuDisable the arg will be the target, the caller the one being converted from

// MenuDisableBeforeToORM called before default ToORM code
type MenuDisableWithBeforeToORM interface {
	BeforeToORM(context.Context, *MenuDisableORM) error
}

// MenuDisableAfterToORM called after default ToORM code
type MenuDisableWithAfterToORM interface {
	AfterToORM(context.Context, *MenuDisableORM) error
}

// MenuDisableBeforeToPB called before default ToPB code
type MenuDisableWithBeforeToPB interface {
	BeforeToPB(context.Context, *MenuDisable) error
}

// MenuDisableAfterToPB called after default ToPB code
type MenuDisableWithAfterToPB interface {
	AfterToPB(context.Context, *MenuDisable) error
}

type MenuLicenseORM struct {
	AccountAlias     string
	AccountID        uint64
	AccountName      string
	AccountNumber    string
	ChargeDate       string `gorm:"type:jsonb"`
	CompanyID        uint64
	CreatedAt        *time.Time
	CreatedByID      uint64
	Fee              uint64
	FeeCurrency      string
	FeeType          string `gorm:"type:varchar(255)"`
	IsAllowed        bool
	IsEnable         bool
	IsModule         bool
	IsTransactional  bool
	Label            string
	MenuID           uint64
	MenuLicenseID    uint64 `gorm:"primary_key;not null"`
	Name             string `gorm:"type:varchar(255)"`
	OrderNumber      string
	ProductID        uint64
	ProductName      string
	TransactionLimit string `gorm:"type:jsonb"`
	UpdatedAt        *time.Time
	UpdatedByID      uint64
}

// TableName overrides the default tablename generated by GORM
func (MenuLicenseORM) TableName() string {
	return "menu_licenses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MenuLicense) ToORM(ctx context.Context) (MenuLicenseORM, error) {
	to := MenuLicenseORM{}
	var err error
	if prehook, ok := interface{}(m).(MenuLicenseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MenuLicenseID = m.MenuLicenseID
	to.CompanyID = m.CompanyID
	to.IsAllowed = m.IsAllowed
	to.Fee = m.Fee
	to.FeeType = m.FeeType
	to.TransactionLimit = m.TransactionLimit
	to.ProductID = m.ProductID
	to.ProductName = m.ProductName
	to.ChargeDate = m.ChargeDate
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UpdatedByID = m.UpdatedByID
	to.Name = m.Name
	to.IsEnable = m.IsEnable
	to.AccountID = m.AccountID
	to.AccountNumber = m.AccountNumber
	to.AccountName = m.AccountName
	to.MenuID = m.MenuID
	to.Label = m.Label
	to.IsModule = m.IsModule
	to.FeeCurrency = m.FeeCurrency
	to.OrderNumber = m.OrderNumber
	to.AccountAlias = m.AccountAlias
	to.IsTransactional = m.IsTransactional
	if posthook, ok := interface{}(m).(MenuLicenseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MenuLicenseORM) ToPB(ctx context.Context) (MenuLicense, error) {
	to := MenuLicense{}
	var err error
	if prehook, ok := interface{}(m).(MenuLicenseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MenuLicenseID = m.MenuLicenseID
	to.CompanyID = m.CompanyID
	to.IsAllowed = m.IsAllowed
	to.Fee = m.Fee
	to.FeeType = m.FeeType
	to.TransactionLimit = m.TransactionLimit
	to.ProductID = m.ProductID
	to.ProductName = m.ProductName
	to.ChargeDate = m.ChargeDate
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.CreatedByID = m.CreatedByID
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UpdatedByID = m.UpdatedByID
	to.Name = m.Name
	to.IsEnable = m.IsEnable
	to.AccountID = m.AccountID
	to.AccountNumber = m.AccountNumber
	to.AccountName = m.AccountName
	to.MenuID = m.MenuID
	to.Label = m.Label
	to.IsModule = m.IsModule
	to.FeeCurrency = m.FeeCurrency
	to.OrderNumber = m.OrderNumber
	to.AccountAlias = m.AccountAlias
	to.IsTransactional = m.IsTransactional
	if posthook, ok := interface{}(m).(MenuLicenseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MenuLicense the arg will be the target, the caller the one being converted from

// MenuLicenseBeforeToORM called before default ToORM code
type MenuLicenseWithBeforeToORM interface {
	BeforeToORM(context.Context, *MenuLicenseORM) error
}

// MenuLicenseAfterToORM called after default ToORM code
type MenuLicenseWithAfterToORM interface {
	AfterToORM(context.Context, *MenuLicenseORM) error
}

// MenuLicenseBeforeToPB called before default ToPB code
type MenuLicenseWithBeforeToPB interface {
	BeforeToPB(context.Context, *MenuLicense) error
}

// MenuLicenseAfterToPB called after default ToPB code
type MenuLicenseWithAfterToPB interface {
	AfterToPB(context.Context, *MenuLicense) error
}

type MenuTaskORM struct {
	MenuID uint64
	TaskID uint64 `gorm:"primary_key;not null"`
}

// TableName overrides the default tablename generated by GORM
func (MenuTaskORM) TableName() string {
	return "menu_tasks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MenuTask) ToORM(ctx context.Context) (MenuTaskORM, error) {
	to := MenuTaskORM{}
	var err error
	if prehook, ok := interface{}(m).(MenuTaskWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TaskID = m.TaskID
	to.MenuID = m.MenuID
	if posthook, ok := interface{}(m).(MenuTaskWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MenuTaskORM) ToPB(ctx context.Context) (MenuTask, error) {
	to := MenuTask{}
	var err error
	if prehook, ok := interface{}(m).(MenuTaskWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.TaskID = m.TaskID
	to.MenuID = m.MenuID
	if posthook, ok := interface{}(m).(MenuTaskWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MenuTask the arg will be the target, the caller the one being converted from

// MenuTaskBeforeToORM called before default ToORM code
type MenuTaskWithBeforeToORM interface {
	BeforeToORM(context.Context, *MenuTaskORM) error
}

// MenuTaskAfterToORM called after default ToORM code
type MenuTaskWithAfterToORM interface {
	AfterToORM(context.Context, *MenuTaskORM) error
}

// MenuTaskBeforeToPB called before default ToPB code
type MenuTaskWithBeforeToPB interface {
	BeforeToPB(context.Context, *MenuTask) error
}

// MenuTaskAfterToPB called after default ToPB code
type MenuTaskWithAfterToPB interface {
	AfterToPB(context.Context, *MenuTask) error
}

type CompanyORM struct {
	CompanyID   uint64     `gorm:"column:CompanyID;primary_key;not null"`
	CreatedAt   *time.Time `gorm:"not null"`
	CreatedByID uint64     `gorm:"column:CreatedByID"`
	DeletedAt   *time.Time
	DeletedByID uint64     `gorm:"column:DeletedByID"`
	Name        string     `gorm:"column:Name;type:varchar(150);not null"`
	UpdatedAt   *time.Time `gorm:"not null"`
	UpdatedByID uint64     `gorm:"column:UpdatedByID"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyORM) TableName() string {
	return "company"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Company) ToORM(ctx context.Context) (CompanyORM, error) {
	to := CompanyORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.Name = m.Name
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		t := m.DeletedAt.AsTime()
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(CompanyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyORM) ToPB(ctx context.Context) (Company, error) {
	to := Company{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyID = m.CompanyID
	to.Name = m.Name
	to.CreatedByID = m.CreatedByID
	to.UpdatedByID = m.UpdatedByID
	to.DeletedByID = m.DeletedByID
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.DeletedAt != nil {
		to.DeletedAt = timestamppb.New(*m.DeletedAt)
	}
	if posthook, ok := interface{}(m).(CompanyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Company the arg will be the target, the caller the one being converted from

// CompanyBeforeToORM called before default ToORM code
type CompanyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyORM) error
}

// CompanyAfterToORM called after default ToORM code
type CompanyWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyORM) error
}

// CompanyBeforeToPB called before default ToPB code
type CompanyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Company) error
}

// CompanyAfterToPB called after default ToPB code
type CompanyWithAfterToPB interface {
	AfterToPB(context.Context, *Company) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"Role" {
			patchee.Role = patcher.Role
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateModule executes a basic gorm create call
func DefaultCreateModule(ctx context.Context, in *Module, db *gorm.DB) (*Module, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ModuleORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadModule(ctx context.Context, in *Module, db *gorm.DB) (*Module, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.ModuleID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ModuleORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ModuleORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ModuleORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ModuleORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteModule(ctx context.Context, in *Module, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.ModuleID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ModuleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ModuleORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteModuleSet(ctx context.Context, in []*Module, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.ModuleID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.ModuleID)
	}
	if hook, ok := (interface{}(&ModuleORM{})).(ModuleORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("module_id in (?)", keys).Delete(&ModuleORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ModuleORM{})).(ModuleORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ModuleORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Module, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Module, *gorm.DB) error
}

// DefaultStrictUpdateModule clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateModule(ctx context.Context, in *Module, db *gorm.DB) (*Module, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateModule")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ModuleORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("module_id=?", ormObj.ModuleID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ModuleORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchModule executes a basic gorm update call with patch behavior
func DefaultPatchModule(ctx context.Context, in *Module, updateMask *field_mask.FieldMask, db *gorm.DB) (*Module, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Module
	var err error
	if hook, ok := interface{}(&pbObj).(ModuleWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(ModuleWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskModule(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ModuleWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateModule(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ModuleWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ModuleWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Module, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Module, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Module, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ModuleWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Module, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetModule executes a bulk gorm update call with patch behavior
func DefaultPatchSetModule(ctx context.Context, objects []*Module, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Module, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Module, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchModule(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskModule patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskModule(ctx context.Context, patchee *Module, patcher *Module, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Module, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"ModuleID" {
			patchee.ModuleID = patcher.ModuleID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsTransactional" {
			patchee.IsTransactional = patcher.IsTransactional
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListModule executes a gorm list call
func DefaultListModule(ctx context.Context, db *gorm.DB) ([]*Module, error) {
	in := Module{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ModuleORM{}, &Module{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("module_id")
	ormResponse := []ModuleORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ModuleORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Module{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ModuleORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ModuleORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ModuleORM) error
}

// DefaultCreateMenu executes a basic gorm create call
func DefaultCreateMenu(ctx context.Context, in *Menu, db *gorm.DB) (*Menu, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MenuORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMenu(ctx context.Context, in *Menu, db *gorm.DB) (*Menu, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.MenuID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MenuORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MenuORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MenuORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MenuORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMenu(ctx context.Context, in *Menu, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.MenuID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MenuORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MenuORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuSet(ctx context.Context, in []*Menu, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.MenuID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.MenuID)
	}
	if hook, ok := (interface{}(&MenuORM{})).(MenuORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("menu_id in (?)", keys).Delete(&MenuORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MenuORM{})).(MenuORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MenuORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Menu, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Menu, *gorm.DB) error
}

// DefaultStrictUpdateMenu clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMenu(ctx context.Context, in *Menu, db *gorm.DB) (*Menu, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMenu")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MenuORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("MenuID=?", ormObj.MenuID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDisables := MenuDisableORM{}
	if ormObj.MenuID == 0 {
		return nil, errors.EmptyIdError
	}
	filterDisables.MenuID = ormObj.MenuID
	if err = db.Where(filterDisables).Delete(MenuDisableORM{}).Error; err != nil {
		return nil, err
	}
	filterMenus := MenuORM{}
	if ormObj.MenuID == 0 {
		return nil, errors.EmptyIdError
	}
	filterMenus.ParentID = ormObj.MenuID
	if err = db.Where(filterMenus).Delete(MenuORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MenuORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMenu executes a basic gorm update call with patch behavior
func DefaultPatchMenu(ctx context.Context, in *Menu, updateMask *field_mask.FieldMask, db *gorm.DB) (*Menu, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Menu
	var err error
	if hook, ok := interface{}(&pbObj).(MenuWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(MenuWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMenu(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MenuWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMenu(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MenuWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MenuWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Menu, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Menu, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Menu, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Menu, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMenu executes a bulk gorm update call with patch behavior
func DefaultPatchSetMenu(ctx context.Context, objects []*Menu, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Menu, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Menu, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMenu(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMenu patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMenu(ctx context.Context, patchee *Menu, patcher *Menu, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Menu, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"MenuID" {
			patchee.MenuID = patcher.MenuID
			continue
		}
		if f == prefix+"ParentID" {
			patchee.ParentID = patcher.ParentID
			continue
		}
		if f == prefix+"UserType" {
			patchee.UserType = patcher.UserType
			continue
		}
		if f == prefix+"Label" {
			patchee.Label = patcher.Label
			continue
		}
		if f == prefix+"IsModule" {
			patchee.IsModule = patcher.IsModule
			continue
		}
		if f == prefix+"RootPath" {
			patchee.RootPath = patcher.RootPath
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"Menus" {
			patchee.Menus = patcher.Menus
			continue
		}
		if f == prefix+"ProductID" {
			patchee.ProductID = patcher.ProductID
			continue
		}
		if f == prefix+"ProductName" {
			patchee.ProductName = patcher.ProductName
			continue
		}
		if f == prefix+"IsTransactional" {
			patchee.IsTransactional = patcher.IsTransactional
			continue
		}
		if f == prefix+"OrderNumber" {
			patchee.OrderNumber = patcher.OrderNumber
			continue
		}
		if f == prefix+"IconURI" {
			patchee.IconURI = patcher.IconURI
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsEnable" {
			patchee.IsEnable = patcher.IsEnable
			continue
		}
		if f == prefix+"EnableScheduled" {
			patchee.EnableScheduled = patcher.EnableScheduled
			continue
		}
		if f == prefix+"Disables" {
			patchee.Disables = patcher.Disables
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMenu executes a gorm list call
func DefaultListMenu(ctx context.Context, db *gorm.DB) ([]*Menu, error) {
	in := Menu{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MenuORM{}, &Menu{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("MenuID")
	ormResponse := []MenuORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Menu{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MenuORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MenuORM) error
}

// DefaultCreateMenuDisable executes a basic gorm create call
func DefaultCreateMenuDisable(ctx context.Context, in *MenuDisable, db *gorm.DB) (*MenuDisable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MenuDisableORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMenuDisable(ctx context.Context, in *MenuDisable, db *gorm.DB) (*MenuDisable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.MenuDisableID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MenuDisableORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MenuDisableORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MenuDisableORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MenuDisableORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuDisable(ctx context.Context, in *MenuDisable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.MenuDisableID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MenuDisableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MenuDisableORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuDisableSet(ctx context.Context, in []*MenuDisable, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.MenuDisableID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.MenuDisableID)
	}
	if hook, ok := (interface{}(&MenuDisableORM{})).(MenuDisableORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("menu_disable_id in (?)", keys).Delete(&MenuDisableORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MenuDisableORM{})).(MenuDisableORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MenuDisableORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MenuDisable, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MenuDisable, *gorm.DB) error
}

// DefaultStrictUpdateMenuDisable clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMenuDisable(ctx context.Context, in *MenuDisable, db *gorm.DB) (*MenuDisable, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMenuDisable")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MenuDisableORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("MenuDisableID=?", ormObj.MenuDisableID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MenuDisableORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMenuDisable executes a basic gorm update call with patch behavior
func DefaultPatchMenuDisable(ctx context.Context, in *MenuDisable, updateMask *field_mask.FieldMask, db *gorm.DB) (*MenuDisable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MenuDisable
	var err error
	if hook, ok := interface{}(&pbObj).(MenuDisableWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(MenuDisableWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMenuDisable(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MenuDisableWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMenuDisable(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MenuDisableWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MenuDisableWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MenuDisable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MenuDisable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MenuDisable, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MenuDisable, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMenuDisable executes a bulk gorm update call with patch behavior
func DefaultPatchSetMenuDisable(ctx context.Context, objects []*MenuDisable, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MenuDisable, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MenuDisable, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMenuDisable(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMenuDisable patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMenuDisable(ctx context.Context, patchee *MenuDisable, patcher *MenuDisable, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MenuDisable, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedMenu bool
	var updatedStartDateTime bool
	var updatedEndDateTime bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"MenuDisableID" {
			patchee.MenuDisableID = patcher.MenuDisableID
			continue
		}
		if !updatedMenu && strings.HasPrefix(f, prefix+"Menu.") {
			updatedMenu = true
			if patcher.Menu == nil {
				patchee.Menu = nil
				continue
			}
			if patchee.Menu == nil {
				patchee.Menu = &Menu{}
			}
			if o, err := DefaultApplyFieldMaskMenu(ctx, patchee.Menu, patcher.Menu, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Menu.", db); err != nil {
				return nil, err
			} else {
				patchee.Menu = o
			}
			continue
		}
		if f == prefix+"Menu" {
			updatedMenu = true
			patchee.Menu = patcher.Menu
			continue
		}
		if !updatedStartDateTime && strings.HasPrefix(f, prefix+"StartDateTime.") {
			if patcher.StartDateTime == nil {
				patchee.StartDateTime = nil
				continue
			}
			if patchee.StartDateTime == nil {
				patchee.StartDateTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartDateTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartDateTime, patchee.StartDateTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartDateTime" {
			updatedStartDateTime = true
			patchee.StartDateTime = patcher.StartDateTime
			continue
		}
		if !updatedEndDateTime && strings.HasPrefix(f, prefix+"EndDateTime.") {
			if patcher.EndDateTime == nil {
				patchee.EndDateTime = nil
				continue
			}
			if patchee.EndDateTime == nil {
				patchee.EndDateTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndDateTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndDateTime, patchee.EndDateTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndDateTime" {
			updatedEndDateTime = true
			patchee.EndDateTime = patcher.EndDateTime
			continue
		}
		if f == prefix+"CustomTime" {
			patchee.CustomTime = patcher.CustomTime
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if f == prefix+"MenuID" {
			patchee.MenuID = patcher.MenuID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMenuDisable executes a gorm list call
func DefaultListMenuDisable(ctx context.Context, db *gorm.DB) ([]*MenuDisable, error) {
	in := MenuDisable{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MenuDisableORM{}, &MenuDisable{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("MenuDisableID")
	ormResponse := []MenuDisableORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuDisableORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MenuDisable{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MenuDisableORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuDisableORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MenuDisableORM) error
}

// DefaultCreateMenuLicense executes a basic gorm create call
func DefaultCreateMenuLicense(ctx context.Context, in *MenuLicense, db *gorm.DB) (*MenuLicense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MenuLicenseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMenuLicense(ctx context.Context, in *MenuLicense, db *gorm.DB) (*MenuLicense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.MenuLicenseID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MenuLicenseORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MenuLicenseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MenuLicenseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MenuLicenseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuLicense(ctx context.Context, in *MenuLicense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.MenuLicenseID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MenuLicenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MenuLicenseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuLicenseSet(ctx context.Context, in []*MenuLicense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.MenuLicenseID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.MenuLicenseID)
	}
	if hook, ok := (interface{}(&MenuLicenseORM{})).(MenuLicenseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("menu_license_id in (?)", keys).Delete(&MenuLicenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MenuLicenseORM{})).(MenuLicenseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MenuLicenseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MenuLicense, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MenuLicense, *gorm.DB) error
}

// DefaultStrictUpdateMenuLicense clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMenuLicense(ctx context.Context, in *MenuLicense, db *gorm.DB) (*MenuLicense, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMenuLicense")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MenuLicenseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("menu_license_id=?", ormObj.MenuLicenseID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MenuLicenseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMenuLicense executes a basic gorm update call with patch behavior
func DefaultPatchMenuLicense(ctx context.Context, in *MenuLicense, updateMask *field_mask.FieldMask, db *gorm.DB) (*MenuLicense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MenuLicense
	var err error
	if hook, ok := interface{}(&pbObj).(MenuLicenseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(MenuLicenseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMenuLicense(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MenuLicenseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMenuLicense(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MenuLicenseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MenuLicenseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MenuLicense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MenuLicense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MenuLicense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MenuLicense, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMenuLicense executes a bulk gorm update call with patch behavior
func DefaultPatchSetMenuLicense(ctx context.Context, objects []*MenuLicense, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MenuLicense, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MenuLicense, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMenuLicense(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMenuLicense patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMenuLicense(ctx context.Context, patchee *MenuLicense, patcher *MenuLicense, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MenuLicense, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCompany bool
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"MenuLicenseID" {
			patchee.MenuLicenseID = patcher.MenuLicenseID
			continue
		}
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"IsAllowed" {
			patchee.IsAllowed = patcher.IsAllowed
			continue
		}
		if f == prefix+"Fee" {
			patchee.Fee = patcher.Fee
			continue
		}
		if f == prefix+"FeeType" {
			patchee.FeeType = patcher.FeeType
			continue
		}
		if f == prefix+"TransactionLimit" {
			patchee.TransactionLimit = patcher.TransactionLimit
			continue
		}
		if f == prefix+"ProductID" {
			patchee.ProductID = patcher.ProductID
			continue
		}
		if f == prefix+"ProductName" {
			patchee.ProductName = patcher.ProductName
			continue
		}
		if !updatedCompany && strings.HasPrefix(f, prefix+"Company.") {
			if patcher.Company == nil {
				patchee.Company = nil
				continue
			}
			if patchee.Company == nil {
				patchee.Company = &TempCompany{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Company."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Company, patchee.Company, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Company" {
			updatedCompany = true
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ChargeDate" {
			patchee.ChargeDate = patcher.ChargeDate
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsEnable" {
			patchee.IsEnable = patcher.IsEnable
			continue
		}
		if f == prefix+"AccountID" {
			patchee.AccountID = patcher.AccountID
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"AccountName" {
			patchee.AccountName = patcher.AccountName
			continue
		}
		if f == prefix+"MenuID" {
			patchee.MenuID = patcher.MenuID
			continue
		}
		if f == prefix+"Label" {
			patchee.Label = patcher.Label
			continue
		}
		if f == prefix+"IsModule" {
			patchee.IsModule = patcher.IsModule
			continue
		}
		if f == prefix+"FeeCurrency" {
			patchee.FeeCurrency = patcher.FeeCurrency
			continue
		}
		if f == prefix+"OrderNumber" {
			patchee.OrderNumber = patcher.OrderNumber
			continue
		}
		if f == prefix+"AccountAlias" {
			patchee.AccountAlias = patcher.AccountAlias
			continue
		}
		if f == prefix+"IsTransactional" {
			patchee.IsTransactional = patcher.IsTransactional
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMenuLicense executes a gorm list call
func DefaultListMenuLicense(ctx context.Context, db *gorm.DB) ([]*MenuLicense, error) {
	in := MenuLicense{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MenuLicenseORM{}, &MenuLicense{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("menu_license_id")
	ormResponse := []MenuLicenseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuLicenseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MenuLicense{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MenuLicenseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuLicenseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MenuLicenseORM) error
}

// DefaultCreateMenuTask executes a basic gorm create call
func DefaultCreateMenuTask(ctx context.Context, in *MenuTask, db *gorm.DB) (*MenuTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MenuTaskORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMenuTask(ctx context.Context, in *MenuTask, db *gorm.DB) (*MenuTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.TaskID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MenuTaskORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MenuTaskORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MenuTaskORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MenuTaskORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuTask(ctx context.Context, in *MenuTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.TaskID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MenuTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MenuTaskORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMenuTaskSet(ctx context.Context, in []*MenuTask, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.TaskID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.TaskID)
	}
	if hook, ok := (interface{}(&MenuTaskORM{})).(MenuTaskORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("task_id in (?)", keys).Delete(&MenuTaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MenuTaskORM{})).(MenuTaskORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MenuTaskORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MenuTask, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MenuTask, *gorm.DB) error
}

// DefaultStrictUpdateMenuTask clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMenuTask(ctx context.Context, in *MenuTask, db *gorm.DB) (*MenuTask, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMenuTask")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MenuTaskORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("task_id=?", ormObj.TaskID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MenuTaskORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMenuTask executes a basic gorm update call with patch behavior
func DefaultPatchMenuTask(ctx context.Context, in *MenuTask, updateMask *field_mask.FieldMask, db *gorm.DB) (*MenuTask, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MenuTask
	var err error
	if hook, ok := interface{}(&pbObj).(MenuTaskWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(MenuTaskWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMenuTask(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MenuTaskWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMenuTask(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MenuTaskWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MenuTaskWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MenuTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MenuTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MenuTask, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MenuTask, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMenuTask executes a bulk gorm update call with patch behavior
func DefaultPatchSetMenuTask(ctx context.Context, objects []*MenuTask, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MenuTask, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MenuTask, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMenuTask(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMenuTask patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMenuTask(ctx context.Context, patchee *MenuTask, patcher *MenuTask, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MenuTask, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"TaskID" {
			patchee.TaskID = patcher.TaskID
			continue
		}
		if f == prefix+"MenuID" {
			patchee.MenuID = patcher.MenuID
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMenuTask executes a gorm list call
func DefaultListMenuTask(ctx context.Context, db *gorm.DB) ([]*MenuTask, error) {
	in := MenuTask{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MenuTaskORM{}, &MenuTask{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("task_id")
	ormResponse := []MenuTaskORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MenuTaskORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MenuTask{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MenuTaskORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MenuTaskORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MenuTaskORM) error
}

// DefaultCreateCompany executes a basic gorm create call
func DefaultCreateCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.CompanyID == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompany(ctx context.Context, in *Company, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.CompanyID == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanySet(ctx context.Context, in []*Company, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.CompanyID == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.CompanyID)
	}
	if hook, ok := (interface{}(&CompanyORM{})).(CompanyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("company_id in (?)", keys).Delete(&CompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyORM{})).(CompanyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Company, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Company, *gorm.DB) error
}

// DefaultStrictUpdateCompany clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompany")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("CompanyID=?", ormObj.CompanyID).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompany executes a basic gorm update call with patch behavior
func DefaultPatchCompany(ctx context.Context, in *Company, updateMask *field_mask.FieldMask, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Company
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompany(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompany(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompany executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompany(ctx context.Context, objects []*Company, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Company, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Company, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompany(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompany patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompany(ctx context.Context, patchee *Company, patcher *Company, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Company, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedDeletedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"CompanyID" {
			patchee.CompanyID = patcher.CompanyID
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"CreatedByID" {
			patchee.CreatedByID = patcher.CreatedByID
			continue
		}
		if f == prefix+"UpdatedByID" {
			patchee.UpdatedByID = patcher.UpdatedByID
			continue
		}
		if f == prefix+"DeletedByID" {
			patchee.DeletedByID = patcher.DeletedByID
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedDeletedAt && strings.HasPrefix(f, prefix+"DeletedAt.") {
			if patcher.DeletedAt == nil {
				patchee.DeletedAt = nil
				continue
			}
			if patchee.DeletedAt == nil {
				patchee.DeletedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeletedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeletedAt, patchee.DeletedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeletedAt" {
			updatedDeletedAt = true
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompany executes a gorm list call
func DefaultListCompany(ctx context.Context, db *gorm.DB) ([]*Company, error) {
	in := Company{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyORM{}, &Company{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("CompanyID")
	ormResponse := []CompanyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Company{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyORM) error
}
