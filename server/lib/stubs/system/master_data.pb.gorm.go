package pb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type MdBankKliringORM struct {
	Address1      string `gorm:"column:ADDRESS1"`
	Address2      string `gorm:"column:ADDRESS2"`
	Address3      string `gorm:"column:ADDRESS3"`
	BankCode      string `gorm:"column:BANKCODE"`
	Code          string `gorm:"column:CODE"`
	EntityId      string `gorm:"column:ENTITYID"`
	Id            string `gorm:"column:ID;primary_key;not null"`
	JenisUsaha    string `gorm:"column:JENISUSAHA"`
	KodeInduk     string `gorm:"column:KODEINDUK"`
	LastUpdate    string `gorm:"column:LASTUPDATE"`
	Nama          string `gorm:"column:NAMA"`
	SandiKota     string `gorm:"column:SANDIKOTA"`
	SandiPropinsi string `gorm:"column:SANDIPROPINSI"`
}

// TableName overrides the default tablename generated by GORM
func (MdBankKliringORM) TableName() string {
	return "md_bankkliring"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdBankKliring) ToORM(ctx context.Context) (MdBankKliringORM, error) {
	to := MdBankKliringORM{}
	var err error
	if prehook, ok := interface{}(m).(MdBankKliringWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Code = m.Code
	to.KodeInduk = m.KodeInduk
	to.EntityId = m.EntityId
	to.Nama = m.Nama
	to.Address1 = m.Address1
	to.Address2 = m.Address2
	to.Address3 = m.Address3
	to.BankCode = m.BankCode
	to.SandiKota = m.SandiKota
	to.SandiPropinsi = m.SandiPropinsi
	to.LastUpdate = m.LastUpdate
	to.JenisUsaha = m.JenisUsaha
	if posthook, ok := interface{}(m).(MdBankKliringWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdBankKliringORM) ToPB(ctx context.Context) (MdBankKliring, error) {
	to := MdBankKliring{}
	var err error
	if prehook, ok := interface{}(m).(MdBankKliringWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Code = m.Code
	to.KodeInduk = m.KodeInduk
	to.EntityId = m.EntityId
	to.Nama = m.Nama
	to.Address1 = m.Address1
	to.Address2 = m.Address2
	to.Address3 = m.Address3
	to.BankCode = m.BankCode
	to.SandiKota = m.SandiKota
	to.SandiPropinsi = m.SandiPropinsi
	to.LastUpdate = m.LastUpdate
	to.JenisUsaha = m.JenisUsaha
	if posthook, ok := interface{}(m).(MdBankKliringWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdBankKliring the arg will be the target, the caller the one being converted from

// MdBankKliringBeforeToORM called before default ToORM code
type MdBankKliringWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdBankKliringORM) error
}

// MdBankKliringAfterToORM called after default ToORM code
type MdBankKliringWithAfterToORM interface {
	AfterToORM(context.Context, *MdBankKliringORM) error
}

// MdBankKliringBeforeToPB called before default ToPB code
type MdBankKliringWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdBankKliring) error
}

// MdBankKliringAfterToPB called after default ToPB code
type MdBankKliringWithAfterToPB interface {
	AfterToPB(context.Context, *MdBankKliring) error
}

type MdBicccORM struct {
	Address     string `gorm:"column:address"`
	Address1    string `gorm:"column:address_1"`
	Address2    string `gorm:"column:address_2"`
	Address3    string `gorm:"column:address_3"`
	Bic         string `gorm:"primary_key;not null"`
	City        string `gorm:"column:city"`
	Country     string `gorm:"column:country"`
	Countrycode string `gorm:"column:countrycode"`
	GpiMember   int32  `gorm:"column:gpi_member"`
	Institution string `gorm:"column:institution"`
	Location    string `gorm:"column:LOCATION"`
}

// TableName overrides the default tablename generated by GORM
func (MdBicccORM) TableName() string {
	return "md_biccc"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdBiccc) ToORM(ctx context.Context) (MdBicccORM, error) {
	to := MdBicccORM{}
	var err error
	if prehook, ok := interface{}(m).(MdBicccWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Bic = m.Bic
	to.Institution = m.Institution
	to.Country = m.Country
	to.City = m.City
	to.Address = m.Address
	to.Location = m.Location
	to.Address1 = m.Address1
	to.Address2 = m.Address2
	to.Address3 = m.Address3
	to.Countrycode = m.Countrycode
	to.GpiMember = m.GpiMember
	if posthook, ok := interface{}(m).(MdBicccWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdBicccORM) ToPB(ctx context.Context) (MdBiccc, error) {
	to := MdBiccc{}
	var err error
	if prehook, ok := interface{}(m).(MdBicccWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Bic = m.Bic
	to.Institution = m.Institution
	to.Country = m.Country
	to.City = m.City
	to.Address = m.Address
	to.Location = m.Location
	to.Address1 = m.Address1
	to.Address2 = m.Address2
	to.Address3 = m.Address3
	to.Countrycode = m.Countrycode
	to.GpiMember = m.GpiMember
	if posthook, ok := interface{}(m).(MdBicccWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdBiccc the arg will be the target, the caller the one being converted from

// MdBicccBeforeToORM called before default ToORM code
type MdBicccWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdBicccORM) error
}

// MdBicccAfterToORM called after default ToORM code
type MdBicccWithAfterToORM interface {
	AfterToORM(context.Context, *MdBicccORM) error
}

// MdBicccBeforeToPB called before default ToPB code
type MdBicccWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdBiccc) error
}

// MdBicccAfterToPB called after default ToPB code
type MdBicccWithAfterToPB interface {
	AfterToPB(context.Context, *MdBiccc) error
}

type MdBenefTypeORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdBenefTypeORM) TableName() string {
	return "md_benef_type"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdBenefType) ToORM(ctx context.Context) (MdBenefTypeORM, error) {
	to := MdBenefTypeORM{}
	var err error
	if prehook, ok := interface{}(m).(MdBenefTypeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdBenefTypeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdBenefTypeORM) ToPB(ctx context.Context) (MdBenefType, error) {
	to := MdBenefType{}
	var err error
	if prehook, ok := interface{}(m).(MdBenefTypeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdBenefTypeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdBenefType the arg will be the target, the caller the one being converted from

// MdBenefTypeBeforeToORM called before default ToORM code
type MdBenefTypeWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdBenefTypeORM) error
}

// MdBenefTypeAfterToORM called after default ToORM code
type MdBenefTypeWithAfterToORM interface {
	AfterToORM(context.Context, *MdBenefTypeORM) error
}

// MdBenefTypeBeforeToPB called before default ToPB code
type MdBenefTypeWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdBenefType) error
}

// MdBenefTypeAfterToPB called after default ToPB code
type MdBenefTypeWithAfterToPB interface {
	AfterToPB(context.Context, *MdBenefType) error
}

type MdCountryORM struct {
	CountryCode  string `gorm:"column:country_code"`
	CountryCode3 string `gorm:"column:country_code3"`
	CurrencyCode string `gorm:"column:curr_code"`
	CurrencyName string `gorm:"column:curr_name"`
	Description  string `gorm:"column:description"`
	IdCountry    uint64 `gorm:"column:id_country;primary_key;not null"`
	PhoneCode    string `gorm:"column:phone_code"`
}

// TableName overrides the default tablename generated by GORM
func (MdCountryORM) TableName() string {
	return "md_country"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdCountry) ToORM(ctx context.Context) (MdCountryORM, error) {
	to := MdCountryORM{}
	var err error
	if prehook, ok := interface{}(m).(MdCountryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.IdCountry = m.IdCountry
	to.CountryCode = m.CountryCode
	to.CountryCode3 = m.CountryCode3
	to.Description = m.Description
	to.PhoneCode = m.PhoneCode
	to.CurrencyCode = m.CurrencyCode
	to.CurrencyName = m.CurrencyName
	if posthook, ok := interface{}(m).(MdCountryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdCountryORM) ToPB(ctx context.Context) (MdCountry, error) {
	to := MdCountry{}
	var err error
	if prehook, ok := interface{}(m).(MdCountryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.IdCountry = m.IdCountry
	to.CountryCode = m.CountryCode
	to.CountryCode3 = m.CountryCode3
	to.Description = m.Description
	to.PhoneCode = m.PhoneCode
	to.CurrencyCode = m.CurrencyCode
	to.CurrencyName = m.CurrencyName
	if posthook, ok := interface{}(m).(MdCountryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdCountry the arg will be the target, the caller the one being converted from

// MdCountryBeforeToORM called before default ToORM code
type MdCountryWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdCountryORM) error
}

// MdCountryAfterToORM called after default ToORM code
type MdCountryWithAfterToORM interface {
	AfterToORM(context.Context, *MdCountryORM) error
}

// MdCountryBeforeToPB called before default ToPB code
type MdCountryWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdCountry) error
}

// MdCountryAfterToPB called after default ToPB code
type MdCountryWithAfterToPB interface {
	AfterToPB(context.Context, *MdCountry) error
}

type MdEmploymentIndustryORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdEmploymentIndustryORM) TableName() string {
	return "md_employment_industry"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdEmploymentIndustry) ToORM(ctx context.Context) (MdEmploymentIndustryORM, error) {
	to := MdEmploymentIndustryORM{}
	var err error
	if prehook, ok := interface{}(m).(MdEmploymentIndustryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdEmploymentIndustryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdEmploymentIndustryORM) ToPB(ctx context.Context) (MdEmploymentIndustry, error) {
	to := MdEmploymentIndustry{}
	var err error
	if prehook, ok := interface{}(m).(MdEmploymentIndustryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdEmploymentIndustryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdEmploymentIndustry the arg will be the target, the caller the one being converted from

// MdEmploymentIndustryBeforeToORM called before default ToORM code
type MdEmploymentIndustryWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdEmploymentIndustryORM) error
}

// MdEmploymentIndustryAfterToORM called after default ToORM code
type MdEmploymentIndustryWithAfterToORM interface {
	AfterToORM(context.Context, *MdEmploymentIndustryORM) error
}

// MdEmploymentIndustryBeforeToPB called before default ToPB code
type MdEmploymentIndustryWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdEmploymentIndustry) error
}

// MdEmploymentIndustryAfterToPB called after default ToPB code
type MdEmploymentIndustryWithAfterToPB interface {
	AfterToPB(context.Context, *MdEmploymentIndustry) error
}

type MdEmploymentPositionORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdEmploymentPositionORM) TableName() string {
	return "md_employment_position"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdEmploymentPosition) ToORM(ctx context.Context) (MdEmploymentPositionORM, error) {
	to := MdEmploymentPositionORM{}
	var err error
	if prehook, ok := interface{}(m).(MdEmploymentPositionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdEmploymentPositionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdEmploymentPositionORM) ToPB(ctx context.Context) (MdEmploymentPosition, error) {
	to := MdEmploymentPosition{}
	var err error
	if prehook, ok := interface{}(m).(MdEmploymentPositionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdEmploymentPositionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdEmploymentPosition the arg will be the target, the caller the one being converted from

// MdEmploymentPositionBeforeToORM called before default ToORM code
type MdEmploymentPositionWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdEmploymentPositionORM) error
}

// MdEmploymentPositionAfterToORM called after default ToORM code
type MdEmploymentPositionWithAfterToORM interface {
	AfterToORM(context.Context, *MdEmploymentPositionORM) error
}

// MdEmploymentPositionBeforeToPB called before default ToPB code
type MdEmploymentPositionWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdEmploymentPosition) error
}

// MdEmploymentPositionAfterToPB called after default ToPB code
type MdEmploymentPositionWithAfterToPB interface {
	AfterToPB(context.Context, *MdEmploymentPosition) error
}

type MdEmploymentStatusORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdEmploymentStatusORM) TableName() string {
	return "md_employment_status"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdEmploymentStatus) ToORM(ctx context.Context) (MdEmploymentStatusORM, error) {
	to := MdEmploymentStatusORM{}
	var err error
	if prehook, ok := interface{}(m).(MdEmploymentStatusWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdEmploymentStatusWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdEmploymentStatusORM) ToPB(ctx context.Context) (MdEmploymentStatus, error) {
	to := MdEmploymentStatus{}
	var err error
	if prehook, ok := interface{}(m).(MdEmploymentStatusWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdEmploymentStatusWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdEmploymentStatus the arg will be the target, the caller the one being converted from

// MdEmploymentStatusBeforeToORM called before default ToORM code
type MdEmploymentStatusWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdEmploymentStatusORM) error
}

// MdEmploymentStatusAfterToORM called after default ToORM code
type MdEmploymentStatusWithAfterToORM interface {
	AfterToORM(context.Context, *MdEmploymentStatusORM) error
}

// MdEmploymentStatusBeforeToPB called before default ToPB code
type MdEmploymentStatusWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdEmploymentStatus) error
}

// MdEmploymentStatusAfterToPB called after default ToPB code
type MdEmploymentStatusWithAfterToPB interface {
	AfterToPB(context.Context, *MdEmploymentStatus) error
}

type MdGenderORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdGenderORM) TableName() string {
	return "md_gender"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdGender) ToORM(ctx context.Context) (MdGenderORM, error) {
	to := MdGenderORM{}
	var err error
	if prehook, ok := interface{}(m).(MdGenderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdGenderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdGenderORM) ToPB(ctx context.Context) (MdGender, error) {
	to := MdGender{}
	var err error
	if prehook, ok := interface{}(m).(MdGenderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdGenderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdGender the arg will be the target, the caller the one being converted from

// MdGenderBeforeToORM called before default ToORM code
type MdGenderWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdGenderORM) error
}

// MdGenderAfterToORM called after default ToORM code
type MdGenderWithAfterToORM interface {
	AfterToORM(context.Context, *MdGenderORM) error
}

// MdGenderBeforeToPB called before default ToPB code
type MdGenderWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdGender) error
}

// MdGenderAfterToPB called after default ToPB code
type MdGenderWithAfterToPB interface {
	AfterToPB(context.Context, *MdGender) error
}

type MdIdTypeORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdIdTypeORM) TableName() string {
	return "md_idtype"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdIdType) ToORM(ctx context.Context) (MdIdTypeORM, error) {
	to := MdIdTypeORM{}
	var err error
	if prehook, ok := interface{}(m).(MdIdTypeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdIdTypeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdIdTypeORM) ToPB(ctx context.Context) (MdIdType, error) {
	to := MdIdType{}
	var err error
	if prehook, ok := interface{}(m).(MdIdTypeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdIdTypeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdIdType the arg will be the target, the caller the one being converted from

// MdIdTypeBeforeToORM called before default ToORM code
type MdIdTypeWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdIdTypeORM) error
}

// MdIdTypeAfterToORM called after default ToORM code
type MdIdTypeWithAfterToORM interface {
	AfterToORM(context.Context, *MdIdTypeORM) error
}

// MdIdTypeBeforeToPB called before default ToPB code
type MdIdTypeWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdIdType) error
}

// MdIdTypeAfterToPB called after default ToPB code
type MdIdTypeWithAfterToPB interface {
	AfterToPB(context.Context, *MdIdType) error
}

type MdKotaORM struct {
	Id           uint64 `gorm:"column:id;primary_key;not null"`
	Name         string `gorm:"column:name"`
	ProvinceCode uint64 `gorm:"column:province_code"`
}

// TableName overrides the default tablename generated by GORM
func (MdKotaORM) TableName() string {
	return "md_kota"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdKota) ToORM(ctx context.Context) (MdKotaORM, error) {
	to := MdKotaORM{}
	var err error
	if prehook, ok := interface{}(m).(MdKotaWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.ProvinceCode = m.ProvinceCode
	if posthook, ok := interface{}(m).(MdKotaWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdKotaORM) ToPB(ctx context.Context) (MdKota, error) {
	to := MdKota{}
	var err error
	if prehook, ok := interface{}(m).(MdKotaWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.ProvinceCode = m.ProvinceCode
	if posthook, ok := interface{}(m).(MdKotaWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdKota the arg will be the target, the caller the one being converted from

// MdKotaBeforeToORM called before default ToORM code
type MdKotaWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdKotaORM) error
}

// MdKotaAfterToORM called after default ToORM code
type MdKotaWithAfterToORM interface {
	AfterToORM(context.Context, *MdKotaORM) error
}

// MdKotaBeforeToPB called before default ToPB code
type MdKotaWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdKota) error
}

// MdKotaAfterToPB called after default ToPB code
type MdKotaWithAfterToPB interface {
	AfterToPB(context.Context, *MdKota) error
}

type MdProvinceORM struct {
	CountryCode uint64 `gorm:"column:country_code"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Name        string `gorm:"column:name"`
}

// TableName overrides the default tablename generated by GORM
func (MdProvinceORM) TableName() string {
	return "md_province"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdProvince) ToORM(ctx context.Context) (MdProvinceORM, error) {
	to := MdProvinceORM{}
	var err error
	if prehook, ok := interface{}(m).(MdProvinceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.CountryCode = m.CountryCode
	if posthook, ok := interface{}(m).(MdProvinceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdProvinceORM) ToPB(ctx context.Context) (MdProvince, error) {
	to := MdProvince{}
	var err error
	if prehook, ok := interface{}(m).(MdProvinceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.CountryCode = m.CountryCode
	if posthook, ok := interface{}(m).(MdProvinceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdProvince the arg will be the target, the caller the one being converted from

// MdProvinceBeforeToORM called before default ToORM code
type MdProvinceWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdProvinceORM) error
}

// MdProvinceAfterToORM called after default ToORM code
type MdProvinceWithAfterToORM interface {
	AfterToORM(context.Context, *MdProvinceORM) error
}

// MdProvinceBeforeToPB called before default ToPB code
type MdProvinceWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdProvince) error
}

// MdProvinceAfterToPB called after default ToPB code
type MdProvinceWithAfterToPB interface {
	AfterToPB(context.Context, *MdProvince) error
}

type MdPurposeORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdPurposeORM) TableName() string {
	return "md_purpose"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdPurpose) ToORM(ctx context.Context) (MdPurposeORM, error) {
	to := MdPurposeORM{}
	var err error
	if prehook, ok := interface{}(m).(MdPurposeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdPurposeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdPurposeORM) ToPB(ctx context.Context) (MdPurpose, error) {
	to := MdPurpose{}
	var err error
	if prehook, ok := interface{}(m).(MdPurposeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdPurposeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdPurpose the arg will be the target, the caller the one being converted from

// MdPurposeBeforeToORM called before default ToORM code
type MdPurposeWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdPurposeORM) error
}

// MdPurposeAfterToORM called after default ToORM code
type MdPurposeWithAfterToORM interface {
	AfterToORM(context.Context, *MdPurposeORM) error
}

// MdPurposeBeforeToPB called before default ToPB code
type MdPurposeWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdPurpose) error
}

// MdPurposeAfterToPB called after default ToPB code
type MdPurposeWithAfterToPB interface {
	AfterToPB(context.Context, *MdPurpose) error
}

type MdPurposeIntendedORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdPurposeIntendedORM) TableName() string {
	return "md_purpose_intended"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdPurposeIntended) ToORM(ctx context.Context) (MdPurposeIntendedORM, error) {
	to := MdPurposeIntendedORM{}
	var err error
	if prehook, ok := interface{}(m).(MdPurposeIntendedWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdPurposeIntendedWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdPurposeIntendedORM) ToPB(ctx context.Context) (MdPurposeIntended, error) {
	to := MdPurposeIntended{}
	var err error
	if prehook, ok := interface{}(m).(MdPurposeIntendedWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdPurposeIntendedWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdPurposeIntended the arg will be the target, the caller the one being converted from

// MdPurposeIntendedBeforeToORM called before default ToORM code
type MdPurposeIntendedWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdPurposeIntendedORM) error
}

// MdPurposeIntendedAfterToORM called after default ToORM code
type MdPurposeIntendedWithAfterToORM interface {
	AfterToORM(context.Context, *MdPurposeIntendedORM) error
}

// MdPurposeIntendedBeforeToPB called before default ToPB code
type MdPurposeIntendedWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdPurposeIntended) error
}

// MdPurposeIntendedAfterToPB called after default ToPB code
type MdPurposeIntendedWithAfterToPB interface {
	AfterToPB(context.Context, *MdPurposeIntended) error
}

type MdRelationToSenderORM struct {
	Description string `gorm:"column:description"`
	Id          uint64 `gorm:"column:id;primary_key;not null"`
	Translate   string `gorm:"column:TRANSLATE"`
}

// TableName overrides the default tablename generated by GORM
func (MdRelationToSenderORM) TableName() string {
	return "md_relation_to_sender"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdRelationToSender) ToORM(ctx context.Context) (MdRelationToSenderORM, error) {
	to := MdRelationToSenderORM{}
	var err error
	if prehook, ok := interface{}(m).(MdRelationToSenderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdRelationToSenderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdRelationToSenderORM) ToPB(ctx context.Context) (MdRelationToSender, error) {
	to := MdRelationToSender{}
	var err error
	if prehook, ok := interface{}(m).(MdRelationToSenderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Description = m.Description
	to.Translate = m.Translate
	if posthook, ok := interface{}(m).(MdRelationToSenderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdRelationToSender the arg will be the target, the caller the one being converted from

// MdRelationToSenderBeforeToORM called before default ToORM code
type MdRelationToSenderWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdRelationToSenderORM) error
}

// MdRelationToSenderAfterToORM called after default ToORM code
type MdRelationToSenderWithAfterToORM interface {
	AfterToORM(context.Context, *MdRelationToSenderORM) error
}

// MdRelationToSenderBeforeToPB called before default ToPB code
type MdRelationToSenderWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdRelationToSender) error
}

// MdRelationToSenderAfterToPB called after default ToPB code
type MdRelationToSenderWithAfterToPB interface {
	AfterToPB(context.Context, *MdRelationToSender) error
}

type MdBranchORM struct {
	Id    uint64 `gorm:"primary_key;not null"`
	Label string `gorm:"not null"`
	Name  string `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (MdBranchORM) TableName() string {
	return "md_branches"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MdBranch) ToORM(ctx context.Context) (MdBranchORM, error) {
	to := MdBranchORM{}
	var err error
	if prehook, ok := interface{}(m).(MdBranchWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Label = m.Label
	if posthook, ok := interface{}(m).(MdBranchWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MdBranchORM) ToPB(ctx context.Context) (MdBranch, error) {
	to := MdBranch{}
	var err error
	if prehook, ok := interface{}(m).(MdBranchWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Label = m.Label
	if posthook, ok := interface{}(m).(MdBranchWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MdBranch the arg will be the target, the caller the one being converted from

// MdBranchBeforeToORM called before default ToORM code
type MdBranchWithBeforeToORM interface {
	BeforeToORM(context.Context, *MdBranchORM) error
}

// MdBranchAfterToORM called after default ToORM code
type MdBranchWithAfterToORM interface {
	AfterToORM(context.Context, *MdBranchORM) error
}

// MdBranchBeforeToPB called before default ToPB code
type MdBranchWithBeforeToPB interface {
	BeforeToPB(context.Context, *MdBranch) error
}

// MdBranchAfterToPB called after default ToPB code
type MdBranchWithAfterToPB interface {
	AfterToPB(context.Context, *MdBranch) error
}

// DefaultCreateMdBankKliring executes a basic gorm create call
func DefaultCreateMdBankKliring(ctx context.Context, in *MdBankKliring, db *gorm.DB) (*MdBankKliring, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdBankKliringORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdBankKliring(ctx context.Context, in *MdBankKliring, db *gorm.DB) (*MdBankKliring, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdBankKliringORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdBankKliringORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdBankKliringORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdBankKliringORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBankKliring(ctx context.Context, in *MdBankKliring, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdBankKliringORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdBankKliringORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBankKliringSet(ctx context.Context, in []*MdBankKliring, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdBankKliringORM{})).(MdBankKliringORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdBankKliringORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdBankKliringORM{})).(MdBankKliringORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdBankKliringORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdBankKliring, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdBankKliring, *gorm.DB) error
}

// DefaultStrictUpdateMdBankKliring clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdBankKliring(ctx context.Context, in *MdBankKliring, db *gorm.DB) (*MdBankKliring, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdBankKliring")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdBankKliringORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("ID=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdBankKliringORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdBankKliring executes a basic gorm update call with patch behavior
func DefaultPatchMdBankKliring(ctx context.Context, in *MdBankKliring, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdBankKliring, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdBankKliring
	var err error
	if hook, ok := interface{}(&pbObj).(MdBankKliringWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdBankKliring(ctx, &MdBankKliring{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdBankKliringWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdBankKliring(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdBankKliringWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdBankKliring(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdBankKliringWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdBankKliringWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdBankKliring, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdBankKliring, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdBankKliring, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdBankKliring, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdBankKliring executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdBankKliring(ctx context.Context, objects []*MdBankKliring, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdBankKliring, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdBankKliring, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdBankKliring(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdBankKliring patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdBankKliring(ctx context.Context, patchee *MdBankKliring, patcher *MdBankKliring, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdBankKliring, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if f == prefix+"KodeInduk" {
			patchee.KodeInduk = patcher.KodeInduk
			continue
		}
		if f == prefix+"EntityId" {
			patchee.EntityId = patcher.EntityId
			continue
		}
		if f == prefix+"Nama" {
			patchee.Nama = patcher.Nama
			continue
		}
		if f == prefix+"Address1" {
			patchee.Address1 = patcher.Address1
			continue
		}
		if f == prefix+"Address2" {
			patchee.Address2 = patcher.Address2
			continue
		}
		if f == prefix+"Address3" {
			patchee.Address3 = patcher.Address3
			continue
		}
		if f == prefix+"BankCode" {
			patchee.BankCode = patcher.BankCode
			continue
		}
		if f == prefix+"SandiKota" {
			patchee.SandiKota = patcher.SandiKota
			continue
		}
		if f == prefix+"SandiPropinsi" {
			patchee.SandiPropinsi = patcher.SandiPropinsi
			continue
		}
		if f == prefix+"LastUpdate" {
			patchee.LastUpdate = patcher.LastUpdate
			continue
		}
		if f == prefix+"JenisUsaha" {
			patchee.JenisUsaha = patcher.JenisUsaha
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdBankKliring executes a gorm list call
func DefaultListMdBankKliring(ctx context.Context, db *gorm.DB) ([]*MdBankKliring, error) {
	in := MdBankKliring{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdBankKliringORM{}, &MdBankKliring{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("ID")
	ormResponse := []MdBankKliringORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBankKliringORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdBankKliring{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdBankKliringORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBankKliringORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdBankKliringORM) error
}

// DefaultCreateMdBiccc executes a basic gorm create call
func DefaultCreateMdBiccc(ctx context.Context, in *MdBiccc, db *gorm.DB) (*MdBiccc, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdBicccORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdBiccc(ctx context.Context, in *MdBiccc, db *gorm.DB) (*MdBiccc, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Bic == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdBicccORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdBicccORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdBicccORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdBicccORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBiccc(ctx context.Context, in *MdBiccc, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Bic == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdBicccORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdBicccORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBicccSet(ctx context.Context, in []*MdBiccc, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Bic == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Bic)
	}
	if hook, ok := (interface{}(&MdBicccORM{})).(MdBicccORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("bic in (?)", keys).Delete(&MdBicccORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdBicccORM{})).(MdBicccORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdBicccORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdBiccc, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdBiccc, *gorm.DB) error
}

// DefaultStrictUpdateMdBiccc clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdBiccc(ctx context.Context, in *MdBiccc, db *gorm.DB) (*MdBiccc, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdBiccc")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdBicccORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("bic=?", ormObj.Bic).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdBicccORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdBiccc executes a basic gorm update call with patch behavior
func DefaultPatchMdBiccc(ctx context.Context, in *MdBiccc, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdBiccc, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdBiccc
	var err error
	if hook, ok := interface{}(&pbObj).(MdBicccWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(MdBicccWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdBiccc(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdBicccWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdBiccc(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdBicccWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdBicccWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdBiccc, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBicccWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdBiccc, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBicccWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdBiccc, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBicccWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdBiccc, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdBiccc executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdBiccc(ctx context.Context, objects []*MdBiccc, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdBiccc, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdBiccc, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdBiccc(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdBiccc patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdBiccc(ctx context.Context, patchee *MdBiccc, patcher *MdBiccc, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdBiccc, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Bic" {
			patchee.Bic = patcher.Bic
			continue
		}
		if f == prefix+"Institution" {
			patchee.Institution = patcher.Institution
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Location" {
			patchee.Location = patcher.Location
			continue
		}
		if f == prefix+"Address1" {
			patchee.Address1 = patcher.Address1
			continue
		}
		if f == prefix+"Address2" {
			patchee.Address2 = patcher.Address2
			continue
		}
		if f == prefix+"Address3" {
			patchee.Address3 = patcher.Address3
			continue
		}
		if f == prefix+"Countrycode" {
			patchee.Countrycode = patcher.Countrycode
			continue
		}
		if f == prefix+"GpiMember" {
			patchee.GpiMember = patcher.GpiMember
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdBiccc executes a gorm list call
func DefaultListMdBiccc(ctx context.Context, db *gorm.DB) ([]*MdBiccc, error) {
	in := MdBiccc{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdBicccORM{}, &MdBiccc{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("bic")
	ormResponse := []MdBicccORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBicccORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdBiccc{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdBicccORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBicccORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdBicccORM) error
}

// DefaultCreateMdBenefType executes a basic gorm create call
func DefaultCreateMdBenefType(ctx context.Context, in *MdBenefType, db *gorm.DB) (*MdBenefType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdBenefTypeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdBenefType(ctx context.Context, in *MdBenefType, db *gorm.DB) (*MdBenefType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdBenefTypeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdBenefTypeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdBenefTypeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdBenefTypeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBenefType(ctx context.Context, in *MdBenefType, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdBenefTypeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdBenefTypeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBenefTypeSet(ctx context.Context, in []*MdBenefType, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdBenefTypeORM{})).(MdBenefTypeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdBenefTypeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdBenefTypeORM{})).(MdBenefTypeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdBenefTypeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdBenefType, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdBenefType, *gorm.DB) error
}

// DefaultStrictUpdateMdBenefType clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdBenefType(ctx context.Context, in *MdBenefType, db *gorm.DB) (*MdBenefType, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdBenefType")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdBenefTypeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdBenefTypeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdBenefType executes a basic gorm update call with patch behavior
func DefaultPatchMdBenefType(ctx context.Context, in *MdBenefType, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdBenefType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdBenefType
	var err error
	if hook, ok := interface{}(&pbObj).(MdBenefTypeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdBenefType(ctx, &MdBenefType{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdBenefTypeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdBenefType(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdBenefTypeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdBenefType(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdBenefTypeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdBenefTypeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdBenefType, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdBenefType, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdBenefType, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdBenefType, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdBenefType executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdBenefType(ctx context.Context, objects []*MdBenefType, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdBenefType, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdBenefType, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdBenefType(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdBenefType patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdBenefType(ctx context.Context, patchee *MdBenefType, patcher *MdBenefType, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdBenefType, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdBenefType executes a gorm list call
func DefaultListMdBenefType(ctx context.Context, db *gorm.DB) ([]*MdBenefType, error) {
	in := MdBenefType{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdBenefTypeORM{}, &MdBenefType{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdBenefTypeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBenefTypeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdBenefType{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdBenefTypeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBenefTypeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdBenefTypeORM) error
}

// DefaultCreateMdCountry executes a basic gorm create call
func DefaultCreateMdCountry(ctx context.Context, in *MdCountry, db *gorm.DB) (*MdCountry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdCountryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdCountry(ctx context.Context, in *MdCountry, db *gorm.DB) (*MdCountry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.IdCountry == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdCountryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdCountryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdCountryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdCountryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdCountry(ctx context.Context, in *MdCountry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.IdCountry == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdCountryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdCountryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdCountrySet(ctx context.Context, in []*MdCountry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.IdCountry == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.IdCountry)
	}
	if hook, ok := (interface{}(&MdCountryORM{})).(MdCountryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id_country in (?)", keys).Delete(&MdCountryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdCountryORM{})).(MdCountryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdCountryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdCountry, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdCountry, *gorm.DB) error
}

// DefaultStrictUpdateMdCountry clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdCountry(ctx context.Context, in *MdCountry, db *gorm.DB) (*MdCountry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdCountry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdCountryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id_country=?", ormObj.IdCountry).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdCountryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdCountry executes a basic gorm update call with patch behavior
func DefaultPatchMdCountry(ctx context.Context, in *MdCountry, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdCountry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdCountry
	var err error
	if hook, ok := interface{}(&pbObj).(MdCountryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&pbObj).(MdCountryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdCountry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdCountryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdCountry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdCountryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdCountryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdCountry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdCountryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdCountry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdCountryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdCountry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdCountryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdCountry, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdCountry executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdCountry(ctx context.Context, objects []*MdCountry, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdCountry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdCountry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdCountry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdCountry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdCountry(ctx context.Context, patchee *MdCountry, patcher *MdCountry, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdCountry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"IdCountry" {
			patchee.IdCountry = patcher.IdCountry
			continue
		}
		if f == prefix+"CountryCode" {
			patchee.CountryCode = patcher.CountryCode
			continue
		}
		if f == prefix+"CountryCode3" {
			patchee.CountryCode3 = patcher.CountryCode3
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"PhoneCode" {
			patchee.PhoneCode = patcher.PhoneCode
			continue
		}
		if f == prefix+"CurrencyCode" {
			patchee.CurrencyCode = patcher.CurrencyCode
			continue
		}
		if f == prefix+"CurrencyName" {
			patchee.CurrencyName = patcher.CurrencyName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdCountry executes a gorm list call
func DefaultListMdCountry(ctx context.Context, db *gorm.DB) ([]*MdCountry, error) {
	in := MdCountry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdCountryORM{}, &MdCountry{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id_country")
	ormResponse := []MdCountryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdCountryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdCountry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdCountryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdCountryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdCountryORM) error
}

// DefaultCreateMdEmploymentIndustry executes a basic gorm create call
func DefaultCreateMdEmploymentIndustry(ctx context.Context, in *MdEmploymentIndustry, db *gorm.DB) (*MdEmploymentIndustry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdEmploymentIndustryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdEmploymentIndustry(ctx context.Context, in *MdEmploymentIndustry, db *gorm.DB) (*MdEmploymentIndustry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdEmploymentIndustryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdEmploymentIndustryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdEmploymentIndustryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdEmploymentIndustryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdEmploymentIndustry(ctx context.Context, in *MdEmploymentIndustry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdEmploymentIndustryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdEmploymentIndustryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdEmploymentIndustrySet(ctx context.Context, in []*MdEmploymentIndustry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdEmploymentIndustryORM{})).(MdEmploymentIndustryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdEmploymentIndustryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdEmploymentIndustryORM{})).(MdEmploymentIndustryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdEmploymentIndustryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdEmploymentIndustry, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdEmploymentIndustry, *gorm.DB) error
}

// DefaultStrictUpdateMdEmploymentIndustry clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdEmploymentIndustry(ctx context.Context, in *MdEmploymentIndustry, db *gorm.DB) (*MdEmploymentIndustry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdEmploymentIndustry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdEmploymentIndustryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdEmploymentIndustryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdEmploymentIndustry executes a basic gorm update call with patch behavior
func DefaultPatchMdEmploymentIndustry(ctx context.Context, in *MdEmploymentIndustry, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdEmploymentIndustry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdEmploymentIndustry
	var err error
	if hook, ok := interface{}(&pbObj).(MdEmploymentIndustryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdEmploymentIndustry(ctx, &MdEmploymentIndustry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdEmploymentIndustryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdEmploymentIndustry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdEmploymentIndustryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdEmploymentIndustry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdEmploymentIndustryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdEmploymentIndustryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdEmploymentIndustry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdEmploymentIndustry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdEmploymentIndustry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdEmploymentIndustry, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdEmploymentIndustry executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdEmploymentIndustry(ctx context.Context, objects []*MdEmploymentIndustry, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdEmploymentIndustry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdEmploymentIndustry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdEmploymentIndustry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdEmploymentIndustry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdEmploymentIndustry(ctx context.Context, patchee *MdEmploymentIndustry, patcher *MdEmploymentIndustry, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdEmploymentIndustry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdEmploymentIndustry executes a gorm list call
func DefaultListMdEmploymentIndustry(ctx context.Context, db *gorm.DB) ([]*MdEmploymentIndustry, error) {
	in := MdEmploymentIndustry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdEmploymentIndustryORM{}, &MdEmploymentIndustry{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdEmploymentIndustryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentIndustryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdEmploymentIndustry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdEmploymentIndustryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentIndustryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdEmploymentIndustryORM) error
}

// DefaultCreateMdEmploymentPosition executes a basic gorm create call
func DefaultCreateMdEmploymentPosition(ctx context.Context, in *MdEmploymentPosition, db *gorm.DB) (*MdEmploymentPosition, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdEmploymentPositionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdEmploymentPosition(ctx context.Context, in *MdEmploymentPosition, db *gorm.DB) (*MdEmploymentPosition, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdEmploymentPositionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdEmploymentPositionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdEmploymentPositionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdEmploymentPositionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdEmploymentPosition(ctx context.Context, in *MdEmploymentPosition, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdEmploymentPositionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdEmploymentPositionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdEmploymentPositionSet(ctx context.Context, in []*MdEmploymentPosition, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdEmploymentPositionORM{})).(MdEmploymentPositionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdEmploymentPositionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdEmploymentPositionORM{})).(MdEmploymentPositionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdEmploymentPositionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdEmploymentPosition, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdEmploymentPosition, *gorm.DB) error
}

// DefaultStrictUpdateMdEmploymentPosition clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdEmploymentPosition(ctx context.Context, in *MdEmploymentPosition, db *gorm.DB) (*MdEmploymentPosition, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdEmploymentPosition")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdEmploymentPositionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdEmploymentPositionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdEmploymentPosition executes a basic gorm update call with patch behavior
func DefaultPatchMdEmploymentPosition(ctx context.Context, in *MdEmploymentPosition, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdEmploymentPosition, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdEmploymentPosition
	var err error
	if hook, ok := interface{}(&pbObj).(MdEmploymentPositionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdEmploymentPosition(ctx, &MdEmploymentPosition{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdEmploymentPositionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdEmploymentPosition(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdEmploymentPositionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdEmploymentPosition(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdEmploymentPositionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdEmploymentPositionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdEmploymentPosition, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdEmploymentPosition, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdEmploymentPosition, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdEmploymentPosition, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdEmploymentPosition executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdEmploymentPosition(ctx context.Context, objects []*MdEmploymentPosition, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdEmploymentPosition, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdEmploymentPosition, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdEmploymentPosition(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdEmploymentPosition patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdEmploymentPosition(ctx context.Context, patchee *MdEmploymentPosition, patcher *MdEmploymentPosition, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdEmploymentPosition, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdEmploymentPosition executes a gorm list call
func DefaultListMdEmploymentPosition(ctx context.Context, db *gorm.DB) ([]*MdEmploymentPosition, error) {
	in := MdEmploymentPosition{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdEmploymentPositionORM{}, &MdEmploymentPosition{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdEmploymentPositionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentPositionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdEmploymentPosition{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdEmploymentPositionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentPositionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdEmploymentPositionORM) error
}

// DefaultCreateMdEmploymentStatus executes a basic gorm create call
func DefaultCreateMdEmploymentStatus(ctx context.Context, in *MdEmploymentStatus, db *gorm.DB) (*MdEmploymentStatus, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdEmploymentStatusORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdEmploymentStatus(ctx context.Context, in *MdEmploymentStatus, db *gorm.DB) (*MdEmploymentStatus, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdEmploymentStatusORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdEmploymentStatusORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdEmploymentStatusORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdEmploymentStatusORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdEmploymentStatus(ctx context.Context, in *MdEmploymentStatus, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdEmploymentStatusORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdEmploymentStatusORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdEmploymentStatusSet(ctx context.Context, in []*MdEmploymentStatus, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdEmploymentStatusORM{})).(MdEmploymentStatusORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdEmploymentStatusORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdEmploymentStatusORM{})).(MdEmploymentStatusORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdEmploymentStatusORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdEmploymentStatus, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdEmploymentStatus, *gorm.DB) error
}

// DefaultStrictUpdateMdEmploymentStatus clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdEmploymentStatus(ctx context.Context, in *MdEmploymentStatus, db *gorm.DB) (*MdEmploymentStatus, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdEmploymentStatus")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdEmploymentStatusORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdEmploymentStatusORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdEmploymentStatus executes a basic gorm update call with patch behavior
func DefaultPatchMdEmploymentStatus(ctx context.Context, in *MdEmploymentStatus, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdEmploymentStatus, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdEmploymentStatus
	var err error
	if hook, ok := interface{}(&pbObj).(MdEmploymentStatusWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdEmploymentStatus(ctx, &MdEmploymentStatus{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdEmploymentStatusWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdEmploymentStatus(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdEmploymentStatusWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdEmploymentStatus(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdEmploymentStatusWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdEmploymentStatusWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdEmploymentStatus, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdEmploymentStatus, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdEmploymentStatus, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdEmploymentStatus, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdEmploymentStatus executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdEmploymentStatus(ctx context.Context, objects []*MdEmploymentStatus, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdEmploymentStatus, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdEmploymentStatus, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdEmploymentStatus(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdEmploymentStatus patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdEmploymentStatus(ctx context.Context, patchee *MdEmploymentStatus, patcher *MdEmploymentStatus, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdEmploymentStatus, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdEmploymentStatus executes a gorm list call
func DefaultListMdEmploymentStatus(ctx context.Context, db *gorm.DB) ([]*MdEmploymentStatus, error) {
	in := MdEmploymentStatus{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdEmploymentStatusORM{}, &MdEmploymentStatus{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdEmploymentStatusORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdEmploymentStatusORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdEmploymentStatus{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdEmploymentStatusORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdEmploymentStatusORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdEmploymentStatusORM) error
}

// DefaultCreateMdGender executes a basic gorm create call
func DefaultCreateMdGender(ctx context.Context, in *MdGender, db *gorm.DB) (*MdGender, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdGenderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdGender(ctx context.Context, in *MdGender, db *gorm.DB) (*MdGender, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdGenderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdGenderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdGenderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdGenderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdGender(ctx context.Context, in *MdGender, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdGenderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdGenderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdGenderSet(ctx context.Context, in []*MdGender, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdGenderORM{})).(MdGenderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdGenderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdGenderORM{})).(MdGenderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdGenderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdGender, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdGender, *gorm.DB) error
}

// DefaultStrictUpdateMdGender clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdGender(ctx context.Context, in *MdGender, db *gorm.DB) (*MdGender, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdGender")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdGenderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdGenderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdGender executes a basic gorm update call with patch behavior
func DefaultPatchMdGender(ctx context.Context, in *MdGender, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdGender, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdGender
	var err error
	if hook, ok := interface{}(&pbObj).(MdGenderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdGender(ctx, &MdGender{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdGenderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdGender(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdGenderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdGender(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdGenderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdGenderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdGender, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdGenderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdGender, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdGenderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdGender, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdGenderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdGender, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdGender executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdGender(ctx context.Context, objects []*MdGender, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdGender, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdGender, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdGender(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdGender patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdGender(ctx context.Context, patchee *MdGender, patcher *MdGender, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdGender, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdGender executes a gorm list call
func DefaultListMdGender(ctx context.Context, db *gorm.DB) ([]*MdGender, error) {
	in := MdGender{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdGenderORM{}, &MdGender{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdGenderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdGenderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdGender{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdGenderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdGenderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdGenderORM) error
}

// DefaultCreateMdIdType executes a basic gorm create call
func DefaultCreateMdIdType(ctx context.Context, in *MdIdType, db *gorm.DB) (*MdIdType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdIdTypeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdIdType(ctx context.Context, in *MdIdType, db *gorm.DB) (*MdIdType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdIdTypeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdIdTypeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdIdTypeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdIdTypeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdIdType(ctx context.Context, in *MdIdType, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdIdTypeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdIdTypeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdIdTypeSet(ctx context.Context, in []*MdIdType, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdIdTypeORM{})).(MdIdTypeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdIdTypeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdIdTypeORM{})).(MdIdTypeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdIdTypeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdIdType, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdIdType, *gorm.DB) error
}

// DefaultStrictUpdateMdIdType clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdIdType(ctx context.Context, in *MdIdType, db *gorm.DB) (*MdIdType, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdIdType")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdIdTypeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdIdTypeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdIdType executes a basic gorm update call with patch behavior
func DefaultPatchMdIdType(ctx context.Context, in *MdIdType, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdIdType, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdIdType
	var err error
	if hook, ok := interface{}(&pbObj).(MdIdTypeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdIdType(ctx, &MdIdType{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdIdTypeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdIdType(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdIdTypeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdIdType(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdIdTypeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdIdTypeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdIdType, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdIdType, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdIdType, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdIdType, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdIdType executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdIdType(ctx context.Context, objects []*MdIdType, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdIdType, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdIdType, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdIdType(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdIdType patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdIdType(ctx context.Context, patchee *MdIdType, patcher *MdIdType, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdIdType, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdIdType executes a gorm list call
func DefaultListMdIdType(ctx context.Context, db *gorm.DB) ([]*MdIdType, error) {
	in := MdIdType{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdIdTypeORM{}, &MdIdType{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdIdTypeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdIdTypeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdIdType{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdIdTypeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdIdTypeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdIdTypeORM) error
}

// DefaultCreateMdKota executes a basic gorm create call
func DefaultCreateMdKota(ctx context.Context, in *MdKota, db *gorm.DB) (*MdKota, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdKotaORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdKota(ctx context.Context, in *MdKota, db *gorm.DB) (*MdKota, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdKotaORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdKotaORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdKotaORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdKotaORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdKota(ctx context.Context, in *MdKota, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdKotaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdKotaORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdKotaSet(ctx context.Context, in []*MdKota, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdKotaORM{})).(MdKotaORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdKotaORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdKotaORM{})).(MdKotaORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdKotaORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdKota, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdKota, *gorm.DB) error
}

// DefaultStrictUpdateMdKota clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdKota(ctx context.Context, in *MdKota, db *gorm.DB) (*MdKota, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdKota")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdKotaORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdKotaORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdKota executes a basic gorm update call with patch behavior
func DefaultPatchMdKota(ctx context.Context, in *MdKota, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdKota, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdKota
	var err error
	if hook, ok := interface{}(&pbObj).(MdKotaWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdKota(ctx, &MdKota{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdKotaWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdKota(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdKotaWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdKota(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdKotaWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdKotaWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdKota, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdKotaWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdKota, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdKotaWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdKota, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdKotaWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdKota, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdKota executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdKota(ctx context.Context, objects []*MdKota, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdKota, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdKota, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdKota(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdKota patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdKota(ctx context.Context, patchee *MdKota, patcher *MdKota, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdKota, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ProvinceCode" {
			patchee.ProvinceCode = patcher.ProvinceCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdKota executes a gorm list call
func DefaultListMdKota(ctx context.Context, db *gorm.DB) ([]*MdKota, error) {
	in := MdKota{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdKotaORM{}, &MdKota{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdKotaORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdKotaORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdKota{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdKotaORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdKotaORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdKotaORM) error
}

// DefaultCreateMdProvince executes a basic gorm create call
func DefaultCreateMdProvince(ctx context.Context, in *MdProvince, db *gorm.DB) (*MdProvince, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdProvinceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdProvince(ctx context.Context, in *MdProvince, db *gorm.DB) (*MdProvince, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdProvinceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdProvinceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdProvinceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdProvinceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdProvince(ctx context.Context, in *MdProvince, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdProvinceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdProvinceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdProvinceSet(ctx context.Context, in []*MdProvince, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdProvinceORM{})).(MdProvinceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdProvinceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdProvinceORM{})).(MdProvinceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdProvinceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdProvince, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdProvince, *gorm.DB) error
}

// DefaultStrictUpdateMdProvince clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdProvince(ctx context.Context, in *MdProvince, db *gorm.DB) (*MdProvince, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdProvince")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdProvinceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdProvinceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdProvince executes a basic gorm update call with patch behavior
func DefaultPatchMdProvince(ctx context.Context, in *MdProvince, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdProvince, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdProvince
	var err error
	if hook, ok := interface{}(&pbObj).(MdProvinceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdProvince(ctx, &MdProvince{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdProvinceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdProvince(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdProvinceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdProvince(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdProvinceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdProvinceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdProvince, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdProvince, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdProvince, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdProvince, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdProvince executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdProvince(ctx context.Context, objects []*MdProvince, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdProvince, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdProvince, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdProvince(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdProvince patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdProvince(ctx context.Context, patchee *MdProvince, patcher *MdProvince, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdProvince, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"CountryCode" {
			patchee.CountryCode = patcher.CountryCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdProvince executes a gorm list call
func DefaultListMdProvince(ctx context.Context, db *gorm.DB) ([]*MdProvince, error) {
	in := MdProvince{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdProvinceORM{}, &MdProvince{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdProvinceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdProvinceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdProvince{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdProvinceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdProvinceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdProvinceORM) error
}

// DefaultCreateMdPurpose executes a basic gorm create call
func DefaultCreateMdPurpose(ctx context.Context, in *MdPurpose, db *gorm.DB) (*MdPurpose, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdPurposeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdPurpose(ctx context.Context, in *MdPurpose, db *gorm.DB) (*MdPurpose, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdPurposeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdPurposeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdPurposeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdPurposeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdPurpose(ctx context.Context, in *MdPurpose, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdPurposeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdPurposeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdPurposeSet(ctx context.Context, in []*MdPurpose, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdPurposeORM{})).(MdPurposeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdPurposeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdPurposeORM{})).(MdPurposeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdPurposeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdPurpose, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdPurpose, *gorm.DB) error
}

// DefaultStrictUpdateMdPurpose clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdPurpose(ctx context.Context, in *MdPurpose, db *gorm.DB) (*MdPurpose, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdPurpose")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdPurposeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdPurposeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdPurpose executes a basic gorm update call with patch behavior
func DefaultPatchMdPurpose(ctx context.Context, in *MdPurpose, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdPurpose, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdPurpose
	var err error
	if hook, ok := interface{}(&pbObj).(MdPurposeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdPurpose(ctx, &MdPurpose{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdPurposeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdPurpose(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdPurposeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdPurpose(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdPurposeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdPurposeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdPurpose, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdPurpose, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdPurpose, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdPurpose, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdPurpose executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdPurpose(ctx context.Context, objects []*MdPurpose, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdPurpose, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdPurpose, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdPurpose(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdPurpose patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdPurpose(ctx context.Context, patchee *MdPurpose, patcher *MdPurpose, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdPurpose, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdPurpose executes a gorm list call
func DefaultListMdPurpose(ctx context.Context, db *gorm.DB) ([]*MdPurpose, error) {
	in := MdPurpose{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdPurposeORM{}, &MdPurpose{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdPurposeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdPurpose{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdPurposeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdPurposeORM) error
}

// DefaultCreateMdPurposeIntended executes a basic gorm create call
func DefaultCreateMdPurposeIntended(ctx context.Context, in *MdPurposeIntended, db *gorm.DB) (*MdPurposeIntended, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdPurposeIntendedORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdPurposeIntended(ctx context.Context, in *MdPurposeIntended, db *gorm.DB) (*MdPurposeIntended, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdPurposeIntendedORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdPurposeIntendedORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdPurposeIntendedORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdPurposeIntendedORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdPurposeIntended(ctx context.Context, in *MdPurposeIntended, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdPurposeIntendedORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdPurposeIntendedORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdPurposeIntendedSet(ctx context.Context, in []*MdPurposeIntended, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdPurposeIntendedORM{})).(MdPurposeIntendedORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdPurposeIntendedORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdPurposeIntendedORM{})).(MdPurposeIntendedORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdPurposeIntendedORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdPurposeIntended, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdPurposeIntended, *gorm.DB) error
}

// DefaultStrictUpdateMdPurposeIntended clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdPurposeIntended(ctx context.Context, in *MdPurposeIntended, db *gorm.DB) (*MdPurposeIntended, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdPurposeIntended")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdPurposeIntendedORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdPurposeIntendedORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdPurposeIntended executes a basic gorm update call with patch behavior
func DefaultPatchMdPurposeIntended(ctx context.Context, in *MdPurposeIntended, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdPurposeIntended, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdPurposeIntended
	var err error
	if hook, ok := interface{}(&pbObj).(MdPurposeIntendedWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdPurposeIntended(ctx, &MdPurposeIntended{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdPurposeIntendedWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdPurposeIntended(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdPurposeIntendedWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdPurposeIntended(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdPurposeIntendedWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdPurposeIntendedWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdPurposeIntended, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdPurposeIntended, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdPurposeIntended, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdPurposeIntended, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdPurposeIntended executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdPurposeIntended(ctx context.Context, objects []*MdPurposeIntended, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdPurposeIntended, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdPurposeIntended, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdPurposeIntended(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdPurposeIntended patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdPurposeIntended(ctx context.Context, patchee *MdPurposeIntended, patcher *MdPurposeIntended, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdPurposeIntended, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdPurposeIntended executes a gorm list call
func DefaultListMdPurposeIntended(ctx context.Context, db *gorm.DB) ([]*MdPurposeIntended, error) {
	in := MdPurposeIntended{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdPurposeIntendedORM{}, &MdPurposeIntended{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdPurposeIntendedORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdPurposeIntendedORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdPurposeIntended{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdPurposeIntendedORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdPurposeIntendedORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdPurposeIntendedORM) error
}

// DefaultCreateMdRelationToSender executes a basic gorm create call
func DefaultCreateMdRelationToSender(ctx context.Context, in *MdRelationToSender, db *gorm.DB) (*MdRelationToSender, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdRelationToSenderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdRelationToSender(ctx context.Context, in *MdRelationToSender, db *gorm.DB) (*MdRelationToSender, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdRelationToSenderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdRelationToSenderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdRelationToSenderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdRelationToSenderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdRelationToSender(ctx context.Context, in *MdRelationToSender, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdRelationToSenderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdRelationToSenderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdRelationToSenderSet(ctx context.Context, in []*MdRelationToSender, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdRelationToSenderORM{})).(MdRelationToSenderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdRelationToSenderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdRelationToSenderORM{})).(MdRelationToSenderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdRelationToSenderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdRelationToSender, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdRelationToSender, *gorm.DB) error
}

// DefaultStrictUpdateMdRelationToSender clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdRelationToSender(ctx context.Context, in *MdRelationToSender, db *gorm.DB) (*MdRelationToSender, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdRelationToSender")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdRelationToSenderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdRelationToSenderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdRelationToSender executes a basic gorm update call with patch behavior
func DefaultPatchMdRelationToSender(ctx context.Context, in *MdRelationToSender, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdRelationToSender, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdRelationToSender
	var err error
	if hook, ok := interface{}(&pbObj).(MdRelationToSenderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdRelationToSender(ctx, &MdRelationToSender{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdRelationToSenderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdRelationToSender(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdRelationToSenderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdRelationToSender(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdRelationToSenderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdRelationToSenderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdRelationToSender, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdRelationToSender, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdRelationToSender, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdRelationToSender, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdRelationToSender executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdRelationToSender(ctx context.Context, objects []*MdRelationToSender, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdRelationToSender, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdRelationToSender, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdRelationToSender(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdRelationToSender patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdRelationToSender(ctx context.Context, patchee *MdRelationToSender, patcher *MdRelationToSender, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdRelationToSender, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Translate" {
			patchee.Translate = patcher.Translate
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdRelationToSender executes a gorm list call
func DefaultListMdRelationToSender(ctx context.Context, db *gorm.DB) ([]*MdRelationToSender, error) {
	in := MdRelationToSender{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdRelationToSenderORM{}, &MdRelationToSender{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdRelationToSenderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdRelationToSenderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdRelationToSender{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdRelationToSenderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdRelationToSenderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdRelationToSenderORM) error
}

// DefaultCreateMdBranch executes a basic gorm create call
func DefaultCreateMdBranch(ctx context.Context, in *MdBranch, db *gorm.DB) (*MdBranch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MdBranchORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMdBranch(ctx context.Context, in *MdBranch, db *gorm.DB) (*MdBranch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MdBranchORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MdBranchORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MdBranchORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MdBranchORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBranch(ctx context.Context, in *MdBranch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MdBranchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MdBranchORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMdBranchSet(ctx context.Context, in []*MdBranch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MdBranchORM{})).(MdBranchORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MdBranchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MdBranchORM{})).(MdBranchORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MdBranchORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MdBranch, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MdBranch, *gorm.DB) error
}

// DefaultStrictUpdateMdBranch clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMdBranch(ctx context.Context, in *MdBranch, db *gorm.DB) (*MdBranch, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMdBranch")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MdBranchORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MdBranchORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMdBranch executes a basic gorm update call with patch behavior
func DefaultPatchMdBranch(ctx context.Context, in *MdBranch, updateMask *field_mask.FieldMask, db *gorm.DB) (*MdBranch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MdBranch
	var err error
	if hook, ok := interface{}(&pbObj).(MdBranchWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMdBranch(ctx, &MdBranch{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MdBranchWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMdBranch(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MdBranchWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMdBranch(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MdBranchWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MdBranchWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MdBranch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBranchWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MdBranch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBranchWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MdBranch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MdBranchWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MdBranch, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMdBranch executes a bulk gorm update call with patch behavior
func DefaultPatchSetMdBranch(ctx context.Context, objects []*MdBranch, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MdBranch, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MdBranch, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMdBranch(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMdBranch patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMdBranch(ctx context.Context, patchee *MdBranch, patcher *MdBranch, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MdBranch, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Label" {
			patchee.Label = patcher.Label
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMdBranch executes a gorm list call
func DefaultListMdBranch(ctx context.Context, db *gorm.DB) ([]*MdBranch, error) {
	in := MdBranch{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MdBranchORM{}, &MdBranch{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MdBranchORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MdBranchORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MdBranch{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MdBranchORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MdBranchORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MdBranchORM) error
}
